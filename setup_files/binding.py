# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_config_openconfig_platform__components_component_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for each component
  """
  __slots__ = ('_path_helper', '_extmethods', '__name',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'config']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/config/name (string)

    YANG Description: Device name for the component -- this may not be a
configurable parameter on many implementations.  Where
component preconfiguration is supported, for example,
the component name may be configurable.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/config/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Device name for the component -- this may not be a
configurable parameter on many implementations.  Where
component preconfiguration is supported, for example,
the component name may be configurable.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)


  _pyangbind_elements = OrderedDict([('name', name), ])


class yc_temperature_openconfig_platform__components_component_state_temperature(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/state/temperature. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Temperature in degrees Celsius of the component. Values include
the instantaneous, average, minimum, and maximum statistics. If
avg/min/max statistics are not supported, the target is expected
to just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time','__alarm_status','__alarm_threshold','__alarm_severity',)

  _yang_name = 'temperature'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:stat-interval', is_config=False)
    self.__alarm_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="alarm-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:timeticks64', is_config=False)
    self.__alarm_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=False)
    self.__alarm_severity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'MAJOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:MAJOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'WARNING': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:WARNING': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'CRITICAL': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:CRITICAL': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'MINOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:MINOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}},), is_leaf=True, yang_name="alarm-severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'state', u'temperature']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /components/component/state/temperature/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /components/component/state/temperature/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /components/component/state/temperature/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /components/component/state/temperature/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /components/component/state/temperature/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /components/component/state/temperature/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /components/component/state/temperature/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /components/component/state/temperature/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /components/component/state/temperature/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /components/component/state/temperature/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /components/component/state/temperature/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /components/component/state/temperature/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /components/component/state/temperature/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /components/component/state/temperature/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:timeticks64', is_config=False)


  def _get_alarm_status(self):
    """
    Getter method for alarm_status, mapped from YANG variable /components/component/state/temperature/alarm_status (boolean)

    YANG Description: A value of true indicates the alarm has been raised or
asserted.  The value should be false when the alarm is
cleared.
    """
    return self.__alarm_status
      
  def _set_alarm_status(self, v, load=False):
    """
    Setter method for alarm_status, mapped from YANG variable /components/component/state/temperature/alarm_status (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarm_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarm_status() directly.

    YANG Description: A value of true indicates the alarm has been raised or
asserted.  The value should be false when the alarm is
cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="alarm-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alarm_status must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="alarm-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=False)""",
        })

    self.__alarm_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alarm_status(self):
    self.__alarm_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="alarm-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=False)


  def _get_alarm_threshold(self):
    """
    Getter method for alarm_threshold, mapped from YANG variable /components/component/state/temperature/alarm_threshold (uint32)

    YANG Description: The threshold value that was crossed for this alarm.
    """
    return self.__alarm_threshold
      
  def _set_alarm_threshold(self, v, load=False):
    """
    Setter method for alarm_threshold, mapped from YANG variable /components/component/state/temperature/alarm_threshold (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarm_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarm_threshold() directly.

    YANG Description: The threshold value that was crossed for this alarm.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alarm_threshold must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=False)""",
        })

    self.__alarm_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alarm_threshold(self):
    self.__alarm_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=False)


  def _get_alarm_severity(self):
    """
    Getter method for alarm_severity, mapped from YANG variable /components/component/state/temperature/alarm_severity (identityref)

    YANG Description: The severity of the current alarm.
    """
    return self.__alarm_severity
      
  def _set_alarm_severity(self, v, load=False):
    """
    Setter method for alarm_severity, mapped from YANG variable /components/component/state/temperature/alarm_severity (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarm_severity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarm_severity() directly.

    YANG Description: The severity of the current alarm.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'MAJOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:MAJOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'WARNING': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:WARNING': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'CRITICAL': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:CRITICAL': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'MINOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:MINOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}},), is_leaf=True, yang_name="alarm-severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alarm_severity must be of a type compatible with identityref""",
          'defined-type': "openconfig-platform:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'MAJOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:MAJOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'WARNING': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:WARNING': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'CRITICAL': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:CRITICAL': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'MINOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:MINOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}},), is_leaf=True, yang_name="alarm-severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='identityref', is_config=False)""",
        })

    self.__alarm_severity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alarm_severity(self):
    self.__alarm_severity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'MAJOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:MAJOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'WARNING': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:WARNING': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'CRITICAL': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:CRITICAL': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'MINOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}, u'oc-alarm-types:MINOR': {u'@namespace': u'http://openconfig.net/yang/alarms/types', u'@module': u'openconfig-alarm-types'}},), is_leaf=True, yang_name="alarm-severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='identityref', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)
  alarm_status = __builtin__.property(_get_alarm_status)
  alarm_threshold = __builtin__.property(_get_alarm_threshold)
  alarm_severity = __builtin__.property(_get_alarm_severity)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ('alarm_status', alarm_status), ('alarm_threshold', alarm_threshold), ('alarm_severity', alarm_severity), ])


class yc_memory_openconfig_platform__components_component_state_memory(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/state/memory. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: For components that have associated memory, these values
report information about available and utilized memory.
  """
  __slots__ = ('_path_helper', '_extmethods', '__available','__utilized',)

  _yang_name = 'memory'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__available = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="available", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint64', is_config=False)
    self.__utilized = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="utilized", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'state', u'memory']

  def _get_available(self):
    """
    Getter method for available, mapped from YANG variable /components/component/state/memory/available (uint64)

    YANG Description: The available memory physically installed, or logically
allocated to the component.
    """
    return self.__available
      
  def _set_available(self, v, load=False):
    """
    Setter method for available, mapped from YANG variable /components/component/state/memory/available (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_available is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_available() directly.

    YANG Description: The available memory physically installed, or logically
allocated to the component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="available", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """available must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="available", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint64', is_config=False)""",
        })

    self.__available = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_available(self):
    self.__available = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="available", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint64', is_config=False)


  def _get_utilized(self):
    """
    Getter method for utilized, mapped from YANG variable /components/component/state/memory/utilized (uint64)

    YANG Description: The memory currently in use by processes running on
the component, not considering reserved memory that is
not available for use.
    """
    return self.__utilized
      
  def _set_utilized(self, v, load=False):
    """
    Setter method for utilized, mapped from YANG variable /components/component/state/memory/utilized (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_utilized is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_utilized() directly.

    YANG Description: The memory currently in use by processes running on
the component, not considering reserved memory that is
not available for use.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="utilized", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """utilized must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="utilized", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint64', is_config=False)""",
        })

    self.__utilized = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_utilized(self):
    self.__utilized = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="utilized", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint64', is_config=False)

  available = __builtin__.property(_get_available)
  utilized = __builtin__.property(_get_utilized)


  _pyangbind_elements = OrderedDict([('available', available), ('utilized', utilized), ])


class yc_state_openconfig_platform__components_component_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for each component
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__type','__id','__location','__description','__mfg_name','__mfg_date','__hardware_version','__firmware_version','__software_version','__serial_no','__part_no','__removable','__oper_status','__empty','__parent','__temperature','__memory','__allocated_power','__used_power',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__parent = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=False)
    self.__used_power = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="used-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=False)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    self.__software_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    self.__part_no = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    self.__serial_no = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serial-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    self.__hardware_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hardware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    self.__mfg_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mfg-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    self.__mfg_date = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9]{4}\\-[0-9]{2}\\-[0-9]{2}$'}), is_leaf=True, yang_name="mfg-date", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-yang:date', is_config=False)
    self.__allocated_power = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="allocated-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=False)
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'INACTIVE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'ACTIVE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:INACTIVE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:ACTIVE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='identityref', is_config=False)
    self.__location = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    self.__removable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="removable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=False)
    self.__memory = YANGDynClass(base=yc_memory_openconfig_platform__components_component_state_memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=False)
    self.__firmware_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="firmware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    self.__temperature = YANGDynClass(base=yc_temperature_openconfig_platform__components_component_state_temperature, is_container='container', yang_name="temperature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=False)
    self.__type = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:FRU': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'CONTROLLER_CARD': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'STORAGE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'INTEGRATED_CIRCUIT': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'PORT': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:SENSOR': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'CPU': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:LINECARD': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FABRIC': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FAN': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:POWER_SUPPLY': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:PORT': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FAN': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'SENSOR': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:TRANSCEIVER': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:CHASSIS': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'CHASSIS': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FRU': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:INTEGRATED_CIRCUIT': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'BACKPLANE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:STORAGE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FABRIC': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'LINECARD': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-opt-types:OPTICAL_CHANNEL': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-platform-types:CONTROLLER_CARD': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'TRANSCEIVER': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:BACKPLANE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:CPU': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'OPTICAL_CHANNEL': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'POWER_SUPPLY': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:OPERATING_SYSTEM_UPDATE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:OPERATING_SYSTEM': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'OPERATING_SYSTEM': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'OPERATING_SYSTEM_UPDATE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},),], is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=False)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    self.__empty = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="empty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=False)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/state/name (string)

    YANG Description: Device name for the component -- this may not be a
configurable parameter on many implementations.  Where
component preconfiguration is supported, for example,
the component name may be configurable.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/state/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Device name for the component -- this may not be a
configurable parameter on many implementations.  Where
component preconfiguration is supported, for example,
the component name may be configurable.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /components/component/state/type (union)

    YANG Description: Type of component as identified by the system
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /components/component/state/type (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of component as identified by the system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:FRU': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'CONTROLLER_CARD': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'STORAGE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'INTEGRATED_CIRCUIT': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'PORT': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:SENSOR': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'CPU': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:LINECARD': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FABRIC': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FAN': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:POWER_SUPPLY': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:PORT': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FAN': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'SENSOR': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:TRANSCEIVER': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:CHASSIS': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'CHASSIS': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FRU': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:INTEGRATED_CIRCUIT': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'BACKPLANE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:STORAGE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FABRIC': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'LINECARD': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-opt-types:OPTICAL_CHANNEL': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-platform-types:CONTROLLER_CARD': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'TRANSCEIVER': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:BACKPLANE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:CPU': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'OPTICAL_CHANNEL': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'POWER_SUPPLY': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:OPERATING_SYSTEM_UPDATE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:OPERATING_SYSTEM': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'OPERATING_SYSTEM': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'OPERATING_SYSTEM_UPDATE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},),], is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with union""",
          'defined-type': "openconfig-platform:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:FRU': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'CONTROLLER_CARD': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'STORAGE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'INTEGRATED_CIRCUIT': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'PORT': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:SENSOR': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'CPU': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:LINECARD': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FABRIC': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FAN': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:POWER_SUPPLY': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:PORT': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FAN': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'SENSOR': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:TRANSCEIVER': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:CHASSIS': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'CHASSIS': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FRU': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:INTEGRATED_CIRCUIT': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'BACKPLANE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:STORAGE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FABRIC': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'LINECARD': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-opt-types:OPTICAL_CHANNEL': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-platform-types:CONTROLLER_CARD': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'TRANSCEIVER': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:BACKPLANE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:CPU': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'OPTICAL_CHANNEL': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'POWER_SUPPLY': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:OPERATING_SYSTEM_UPDATE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:OPERATING_SYSTEM': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'OPERATING_SYSTEM': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'OPERATING_SYSTEM_UPDATE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},),], is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:FRU': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'CONTROLLER_CARD': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'STORAGE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'INTEGRATED_CIRCUIT': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'PORT': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:SENSOR': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'CPU': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:LINECARD': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FABRIC': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FAN': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:POWER_SUPPLY': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:PORT': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FAN': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'SENSOR': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:TRANSCEIVER': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:CHASSIS': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'CHASSIS': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FRU': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:INTEGRATED_CIRCUIT': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'BACKPLANE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:STORAGE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FABRIC': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'LINECARD': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-opt-types:OPTICAL_CHANNEL': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-platform-types:CONTROLLER_CARD': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'TRANSCEIVER': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:BACKPLANE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:CPU': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'OPTICAL_CHANNEL': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'POWER_SUPPLY': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:OPERATING_SYSTEM_UPDATE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:OPERATING_SYSTEM': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'OPERATING_SYSTEM': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'OPERATING_SYSTEM_UPDATE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},),], is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=False)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /components/component/state/id (string)

    YANG Description: Unique identifier assigned by the system for the
component
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /components/component/state/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier assigned by the system for the
component
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)


  def _get_location(self):
    """
    Getter method for location, mapped from YANG variable /components/component/state/location (string)

    YANG Description: System-supplied description of the location of the
component within the system. This could be a bay position,
slot number, socket location, etc. For component types that
have an explicit slot-id attribute, such as linecards, the
system should populate the more specific slot-id.
    """
    return self.__location
      
  def _set_location(self, v, load=False):
    """
    Setter method for location, mapped from YANG variable /components/component/state/location (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_location is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_location() directly.

    YANG Description: System-supplied description of the location of the
component within the system. This could be a bay position,
slot number, socket location, etc. For component types that
have an explicit slot-id attribute, such as linecards, the
system should populate the more specific slot-id.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """location must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)""",
        })

    self.__location = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_location(self):
    self.__location = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /components/component/state/description (string)

    YANG Description: System-supplied description of the component
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /components/component/state/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: System-supplied description of the component
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)


  def _get_mfg_name(self):
    """
    Getter method for mfg_name, mapped from YANG variable /components/component/state/mfg_name (string)

    YANG Description: System-supplied identifier for the manufacturer of the
component.  This data is particularly useful when a
component manufacturer is different than the overall
device vendor.
    """
    return self.__mfg_name
      
  def _set_mfg_name(self, v, load=False):
    """
    Setter method for mfg_name, mapped from YANG variable /components/component/state/mfg_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mfg_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mfg_name() directly.

    YANG Description: System-supplied identifier for the manufacturer of the
component.  This data is particularly useful when a
component manufacturer is different than the overall
device vendor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="mfg-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mfg_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mfg-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)""",
        })

    self.__mfg_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mfg_name(self):
    self.__mfg_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mfg-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)


  def _get_mfg_date(self):
    """
    Getter method for mfg_date, mapped from YANG variable /components/component/state/mfg_date (oc-yang:date)

    YANG Description: System-supplied representation of the component's
manufacturing date.
    """
    return self.__mfg_date
      
  def _set_mfg_date(self, v, load=False):
    """
    Setter method for mfg_date, mapped from YANG variable /components/component/state/mfg_date (oc-yang:date)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mfg_date is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mfg_date() directly.

    YANG Description: System-supplied representation of the component's
manufacturing date.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9]{4}\\-[0-9]{2}\\-[0-9]{2}$'}), is_leaf=True, yang_name="mfg-date", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-yang:date', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mfg_date must be of a type compatible with oc-yang:date""",
          'defined-type': "oc-yang:date",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9]{4}\\-[0-9]{2}\\-[0-9]{2}$'}), is_leaf=True, yang_name="mfg-date", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-yang:date', is_config=False)""",
        })

    self.__mfg_date = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mfg_date(self):
    self.__mfg_date = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9]{4}\\-[0-9]{2}\\-[0-9]{2}$'}), is_leaf=True, yang_name="mfg-date", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-yang:date', is_config=False)


  def _get_hardware_version(self):
    """
    Getter method for hardware_version, mapped from YANG variable /components/component/state/hardware_version (string)

    YANG Description: For hardware components, this is the hardware revision of
the component.
    """
    return self.__hardware_version
      
  def _set_hardware_version(self, v, load=False):
    """
    Setter method for hardware_version, mapped from YANG variable /components/component/state/hardware_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hardware_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hardware_version() directly.

    YANG Description: For hardware components, this is the hardware revision of
the component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="hardware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hardware_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hardware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)""",
        })

    self.__hardware_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hardware_version(self):
    self.__hardware_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hardware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)


  def _get_firmware_version(self):
    """
    Getter method for firmware_version, mapped from YANG variable /components/component/state/firmware_version (string)

    YANG Description: For hardware components, this is the version of associated
firmware that is running on the component, if applicable.
    """
    return self.__firmware_version
      
  def _set_firmware_version(self, v, load=False):
    """
    Setter method for firmware_version, mapped from YANG variable /components/component/state/firmware_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_firmware_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_firmware_version() directly.

    YANG Description: For hardware components, this is the version of associated
firmware that is running on the component, if applicable.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="firmware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """firmware_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="firmware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)""",
        })

    self.__firmware_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_firmware_version(self):
    self.__firmware_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="firmware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)


  def _get_software_version(self):
    """
    Getter method for software_version, mapped from YANG variable /components/component/state/software_version (string)

    YANG Description: For software components such as operating system or other
software module, this is the version of the currently
running software.
    """
    return self.__software_version
      
  def _set_software_version(self, v, load=False):
    """
    Setter method for software_version, mapped from YANG variable /components/component/state/software_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_software_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_software_version() directly.

    YANG Description: For software components such as operating system or other
software module, this is the version of the currently
running software.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """software_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)""",
        })

    self.__software_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_software_version(self):
    self.__software_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)


  def _get_serial_no(self):
    """
    Getter method for serial_no, mapped from YANG variable /components/component/state/serial_no (string)

    YANG Description: System-assigned serial number of the component.
    """
    return self.__serial_no
      
  def _set_serial_no(self, v, load=False):
    """
    Setter method for serial_no, mapped from YANG variable /components/component/state/serial_no (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serial_no is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serial_no() directly.

    YANG Description: System-assigned serial number of the component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="serial-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serial_no must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serial-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)""",
        })

    self.__serial_no = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serial_no(self):
    self.__serial_no = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serial-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)


  def _get_part_no(self):
    """
    Getter method for part_no, mapped from YANG variable /components/component/state/part_no (string)

    YANG Description: System-assigned part number for the component.  This should
be present in particular if the component is also an FRU
(field replaceable unit)
    """
    return self.__part_no
      
  def _set_part_no(self, v, load=False):
    """
    Setter method for part_no, mapped from YANG variable /components/component/state/part_no (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_part_no is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_part_no() directly.

    YANG Description: System-assigned part number for the component.  This should
be present in particular if the component is also an FRU
(field replaceable unit)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """part_no must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)""",
        })

    self.__part_no = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_part_no(self):
    self.__part_no = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)


  def _get_removable(self):
    """
    Getter method for removable, mapped from YANG variable /components/component/state/removable (boolean)

    YANG Description: If true, this component is removable or is a field
replaceable unit
    """
    return self.__removable
      
  def _set_removable(self, v, load=False):
    """
    Setter method for removable, mapped from YANG variable /components/component/state/removable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_removable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_removable() directly.

    YANG Description: If true, this component is removable or is a field
replaceable unit
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="removable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """removable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="removable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=False)""",
        })

    self.__removable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_removable(self):
    self.__removable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="removable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=False)


  def _get_oper_status(self):
    """
    Getter method for oper_status, mapped from YANG variable /components/component/state/oper_status (identityref)

    YANG Description: If applicable, this reports the current operational status
of the component.
    """
    return self.__oper_status
      
  def _set_oper_status(self, v, load=False):
    """
    Setter method for oper_status, mapped from YANG variable /components/component/state/oper_status (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_status() directly.

    YANG Description: If applicable, this reports the current operational status
of the component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'INACTIVE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'ACTIVE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:INACTIVE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:ACTIVE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_status must be of a type compatible with identityref""",
          'defined-type': "openconfig-platform:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'INACTIVE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'ACTIVE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:INACTIVE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:ACTIVE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='identityref', is_config=False)""",
        })

    self.__oper_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_status(self):
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'INACTIVE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'ACTIVE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:INACTIVE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:ACTIVE': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='identityref', is_config=False)


  def _get_empty(self):
    """
    Getter method for empty, mapped from YANG variable /components/component/state/empty (boolean)

    YANG Description: The empty leaf may be used by the device to indicate that a
component position exists but is not populated.  Using this
flag, it is possible for the management system to learn how
many positions are available (e.g., occupied vs. empty
linecard slots in a chassis).
    """
    return self.__empty
      
  def _set_empty(self, v, load=False):
    """
    Setter method for empty, mapped from YANG variable /components/component/state/empty (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_empty is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_empty() directly.

    YANG Description: The empty leaf may be used by the device to indicate that a
component position exists but is not populated.  Using this
flag, it is possible for the management system to learn how
many positions are available (e.g., occupied vs. empty
linecard slots in a chassis).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="empty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """empty must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="empty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=False)""",
        })

    self.__empty = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_empty(self):
    self.__empty = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="empty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=False)


  def _get_parent(self):
    """
    Getter method for parent, mapped from YANG variable /components/component/state/parent (leafref)

    YANG Description: Reference to the name of the parent component.  Note that
this reference must be kept synchronized with the
corresponding subcomponent reference from the parent
component.
    """
    return self.__parent
      
  def _set_parent(self, v, load=False):
    """
    Setter method for parent, mapped from YANG variable /components/component/state/parent (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parent() directly.

    YANG Description: Reference to the name of the parent component.  Note that
this reference must be kept synchronized with the
corresponding subcomponent reference from the parent
component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="parent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parent must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=False)""",
        })

    self.__parent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parent(self):
    self.__parent = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=False)


  def _get_temperature(self):
    """
    Getter method for temperature, mapped from YANG variable /components/component/state/temperature (container)

    YANG Description: Temperature in degrees Celsius of the component. Values include
the instantaneous, average, minimum, and maximum statistics. If
avg/min/max statistics are not supported, the target is expected
to just supply the instant value
    """
    return self.__temperature
      
  def _set_temperature(self, v, load=False):
    """
    Setter method for temperature, mapped from YANG variable /components/component/state/temperature (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_temperature is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_temperature() directly.

    YANG Description: Temperature in degrees Celsius of the component. Values include
the instantaneous, average, minimum, and maximum statistics. If
avg/min/max statistics are not supported, the target is expected
to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_temperature_openconfig_platform__components_component_state_temperature, is_container='container', yang_name="temperature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """temperature must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_temperature_openconfig_platform__components_component_state_temperature, is_container='container', yang_name="temperature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=False)""",
        })

    self.__temperature = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_temperature(self):
    self.__temperature = YANGDynClass(base=yc_temperature_openconfig_platform__components_component_state_temperature, is_container='container', yang_name="temperature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=False)


  def _get_memory(self):
    """
    Getter method for memory, mapped from YANG variable /components/component/state/memory (container)

    YANG Description: For components that have associated memory, these values
report information about available and utilized memory.
    """
    return self.__memory
      
  def _set_memory(self, v, load=False):
    """
    Setter method for memory, mapped from YANG variable /components/component/state/memory (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memory() directly.

    YANG Description: For components that have associated memory, these values
report information about available and utilized memory.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_memory_openconfig_platform__components_component_state_memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """memory must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_memory_openconfig_platform__components_component_state_memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=False)""",
        })

    self.__memory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_memory(self):
    self.__memory = YANGDynClass(base=yc_memory_openconfig_platform__components_component_state_memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=False)


  def _get_allocated_power(self):
    """
    Getter method for allocated_power, mapped from YANG variable /components/component/state/allocated_power (uint32)

    YANG Description: Power allocated by the system for the component.
    """
    return self.__allocated_power
      
  def _set_allocated_power(self, v, load=False):
    """
    Setter method for allocated_power, mapped from YANG variable /components/component/state/allocated_power (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allocated_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allocated_power() directly.

    YANG Description: Power allocated by the system for the component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="allocated-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allocated_power must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="allocated-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=False)""",
        })

    self.__allocated_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allocated_power(self):
    self.__allocated_power = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="allocated-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=False)


  def _get_used_power(self):
    """
    Getter method for used_power, mapped from YANG variable /components/component/state/used_power (uint32)

    YANG Description: Actual power used by the component.
    """
    return self.__used_power
      
  def _set_used_power(self, v, load=False):
    """
    Setter method for used_power, mapped from YANG variable /components/component/state/used_power (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_used_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_used_power() directly.

    YANG Description: Actual power used by the component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="used-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """used_power must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="used-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=False)""",
        })

    self.__used_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_used_power(self):
    self.__used_power = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="used-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=False)

  name = __builtin__.property(_get_name)
  type = __builtin__.property(_get_type)
  id = __builtin__.property(_get_id)
  location = __builtin__.property(_get_location)
  description = __builtin__.property(_get_description)
  mfg_name = __builtin__.property(_get_mfg_name)
  mfg_date = __builtin__.property(_get_mfg_date)
  hardware_version = __builtin__.property(_get_hardware_version)
  firmware_version = __builtin__.property(_get_firmware_version)
  software_version = __builtin__.property(_get_software_version)
  serial_no = __builtin__.property(_get_serial_no)
  part_no = __builtin__.property(_get_part_no)
  removable = __builtin__.property(_get_removable)
  oper_status = __builtin__.property(_get_oper_status)
  empty = __builtin__.property(_get_empty)
  parent = __builtin__.property(_get_parent)
  temperature = __builtin__.property(_get_temperature)
  memory = __builtin__.property(_get_memory)
  allocated_power = __builtin__.property(_get_allocated_power)
  used_power = __builtin__.property(_get_used_power)


  _pyangbind_elements = OrderedDict([('name', name), ('type', type), ('id', id), ('location', location), ('description', description), ('mfg_name', mfg_name), ('mfg_date', mfg_date), ('hardware_version', hardware_version), ('firmware_version', firmware_version), ('software_version', software_version), ('serial_no', serial_no), ('part_no', part_no), ('removable', removable), ('oper_status', oper_status), ('empty', empty), ('parent', parent), ('temperature', temperature), ('memory', memory), ('allocated_power', allocated_power), ('used_power', used_power), ])


class yc_config_openconfig_platform__components_component_properties_property_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/properties/property/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for each property
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__value',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=[six.text_type,YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64),RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64),RestrictedPrecisionDecimalType(precision=2),], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'properties', u'property', u'config']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/properties/property/config/name (string)

    YANG Description: System-supplied name of the property -- this is typically
non-configurable
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/properties/property/config/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: System-supplied name of the property -- this is typically
non-configurable
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /components/component/properties/property/config/value (union)

    YANG Description: Property values can take on a variety of types.  Signed and
unsigned integer types may be provided in smaller sizes,
e.g., int8, uint16, etc.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /components/component/properties/property/config/value (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Property values can take on a variety of types.  Signed and
unsigned integer types may be provided in smaller sizes,
e.g., int8, uint16, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[six.text_type,YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64),RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64),RestrictedPrecisionDecimalType(precision=2),], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with union""",
          'defined-type': "openconfig-platform:union",
          'generated-type': """YANGDynClass(base=[six.text_type,YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64),RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64),RestrictedPrecisionDecimalType(precision=2),], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=[six.text_type,YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64),RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64),RestrictedPrecisionDecimalType(precision=2),], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('name', name), ('value', value), ])


class yc_state_openconfig_platform__components_component_properties_property_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/properties/property/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for each property
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__value','__configurable',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    self.__value = YANGDynClass(base=[six.text_type,YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64),RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64),RestrictedPrecisionDecimalType(precision=2),], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=False)
    self.__configurable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="configurable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'properties', u'property', u'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/properties/property/state/name (string)

    YANG Description: System-supplied name of the property -- this is typically
non-configurable
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/properties/property/state/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: System-supplied name of the property -- this is typically
non-configurable
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /components/component/properties/property/state/value (union)

    YANG Description: Property values can take on a variety of types.  Signed and
unsigned integer types may be provided in smaller sizes,
e.g., int8, uint16, etc.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /components/component/properties/property/state/value (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Property values can take on a variety of types.  Signed and
unsigned integer types may be provided in smaller sizes,
e.g., int8, uint16, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[six.text_type,YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64),RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64),RestrictedPrecisionDecimalType(precision=2),], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with union""",
          'defined-type': "openconfig-platform:union",
          'generated-type': """YANGDynClass(base=[six.text_type,YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64),RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64),RestrictedPrecisionDecimalType(precision=2),], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=False)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=[six.text_type,YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64),RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64),RestrictedPrecisionDecimalType(precision=2),], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=False)


  def _get_configurable(self):
    """
    Getter method for configurable, mapped from YANG variable /components/component/properties/property/state/configurable (boolean)

    YANG Description: Indication whether the property is user-configurable
    """
    return self.__configurable
      
  def _set_configurable(self, v, load=False):
    """
    Setter method for configurable, mapped from YANG variable /components/component/properties/property/state/configurable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_configurable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_configurable() directly.

    YANG Description: Indication whether the property is user-configurable
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="configurable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """configurable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="configurable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=False)""",
        })

    self.__configurable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_configurable(self):
    self.__configurable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="configurable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=False)

  name = __builtin__.property(_get_name)
  value = __builtin__.property(_get_value)
  configurable = __builtin__.property(_get_configurable)


  _pyangbind_elements = OrderedDict([('name', name), ('value', value), ('configurable', configurable), ])


class yc_property__openconfig_platform__components_component_properties_property(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/properties/property. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of system properties for the component
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__config','__state',)

  _yang_name = 'property'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_platform__components_component_properties_property_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_platform__components_component_properties_property_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'properties', u'property']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/properties/property/name (leafref)

    YANG Description: Reference to the property name.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/properties/property/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the property name.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /components/component/properties/property/config (container)

    YANG Description: Configuration data for each property
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /components/component/properties/property/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for each property
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_platform__components_component_properties_property_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_platform__components_component_properties_property_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_platform__components_component_properties_property_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /components/component/properties/property/state (container)

    YANG Description: Operational state data for each property
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /components/component/properties/property/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for each property
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_platform__components_component_properties_property_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_platform__components_component_properties_property_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_platform__components_component_properties_property_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('name', name), ('config', config), ('state', state), ])


class yc_properties_openconfig_platform__components_component_properties(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/properties. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container 
  """
  __slots__ = ('_path_helper', '_extmethods', '__property_',)

  _yang_name = 'properties'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__property_ = YANGDynClass(base=YANGListType("name",yc_property__openconfig_platform__components_component_properties_property, yang_name="property", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="property", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'properties']

  def _get_property_(self):
    """
    Getter method for property_, mapped from YANG variable /components/component/properties/property (list)

    YANG Description: List of system properties for the component
    """
    return self.__property_
      
  def _set_property_(self, v, load=False):
    """
    Setter method for property_, mapped from YANG variable /components/component/properties/property (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_property_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_property_() directly.

    YANG Description: List of system properties for the component
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_property__openconfig_platform__components_component_properties_property, yang_name="property", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="property", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """property_ must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_property__openconfig_platform__components_component_properties_property, yang_name="property", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="property", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)""",
        })

    self.__property_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_property_(self):
    self.__property_ = YANGDynClass(base=YANGListType("name",yc_property__openconfig_platform__components_component_properties_property, yang_name="property", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="property", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)

  property_ = __builtin__.property(_get_property_, _set_property_)


  _pyangbind_elements = OrderedDict([('property_', property_), ])


class yc_config_openconfig_platform__components_component_subcomponents_subcomponent_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/subcomponents/subcomponent/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the subcomponent
  """
  __slots__ = ('_path_helper', '_extmethods', '__name',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'subcomponents', u'subcomponent', u'config']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/subcomponents/subcomponent/config/name (leafref)

    YANG Description: Reference to the name of the subcomponent
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/subcomponents/subcomponent/config/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the name of the subcomponent
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)


  _pyangbind_elements = OrderedDict([('name', name), ])


class yc_state_openconfig_platform__components_component_subcomponents_subcomponent_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/subcomponents/subcomponent/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the subcomponent
  """
  __slots__ = ('_path_helper', '_extmethods', '__name',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'subcomponents', u'subcomponent', u'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/subcomponents/subcomponent/state/name (leafref)

    YANG Description: Reference to the name of the subcomponent
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/subcomponents/subcomponent/state/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the name of the subcomponent
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=False)

  name = __builtin__.property(_get_name)


  _pyangbind_elements = OrderedDict([('name', name), ])


class yc_subcomponent_openconfig_platform__components_component_subcomponents_subcomponent(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/subcomponents/subcomponent. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of subcomponent references
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__config','__state',)

  _yang_name = 'subcomponent'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_platform__components_component_subcomponents_subcomponent_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_platform__components_component_subcomponents_subcomponent_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'subcomponents', u'subcomponent']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/subcomponents/subcomponent/name (leafref)

    YANG Description: Reference to the name list key
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/subcomponents/subcomponent/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the name list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /components/component/subcomponents/subcomponent/config (container)

    YANG Description: Configuration data for the subcomponent
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /components/component/subcomponents/subcomponent/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the subcomponent
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_platform__components_component_subcomponents_subcomponent_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_platform__components_component_subcomponents_subcomponent_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_platform__components_component_subcomponents_subcomponent_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /components/component/subcomponents/subcomponent/state (container)

    YANG Description: Operational state data for the subcomponent
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /components/component/subcomponents/subcomponent/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for the subcomponent
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_platform__components_component_subcomponents_subcomponent_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_platform__components_component_subcomponents_subcomponent_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_platform__components_component_subcomponents_subcomponent_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('name', name), ('config', config), ('state', state), ])


class yc_subcomponents_openconfig_platform__components_component_subcomponents(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/subcomponents. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for subcomponent references
  """
  __slots__ = ('_path_helper', '_extmethods', '__subcomponent',)

  _yang_name = 'subcomponents'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__subcomponent = YANGDynClass(base=YANGListType("name",yc_subcomponent_openconfig_platform__components_component_subcomponents_subcomponent, yang_name="subcomponent", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="subcomponent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'subcomponents']

  def _get_subcomponent(self):
    """
    Getter method for subcomponent, mapped from YANG variable /components/component/subcomponents/subcomponent (list)

    YANG Description: List of subcomponent references
    """
    return self.__subcomponent
      
  def _set_subcomponent(self, v, load=False):
    """
    Setter method for subcomponent, mapped from YANG variable /components/component/subcomponents/subcomponent (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subcomponent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subcomponent() directly.

    YANG Description: List of subcomponent references
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_subcomponent_openconfig_platform__components_component_subcomponents_subcomponent, yang_name="subcomponent", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="subcomponent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subcomponent must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_subcomponent_openconfig_platform__components_component_subcomponents_subcomponent, yang_name="subcomponent", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="subcomponent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)""",
        })

    self.__subcomponent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subcomponent(self):
    self.__subcomponent = YANGDynClass(base=YANGListType("name",yc_subcomponent_openconfig_platform__components_component_subcomponents_subcomponent, yang_name="subcomponent", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="subcomponent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)

  subcomponent = __builtin__.property(_get_subcomponent, _set_subcomponent)


  _pyangbind_elements = OrderedDict([('subcomponent', subcomponent), ])


class yc_chassis_openconfig_platform__components_component_chassis(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/chassis. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data for chassis components
  """
  _pyangbind_elements = {}

  

class yc_config_openconfig_platform__components_component_port_breakout_mode_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/port/breakout-mode/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for port breakout
  """
  __slots__ = ('_path_helper', '_extmethods', '__num_channels','__channel_speed',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__channel_speed = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-eth:SPEED_5GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_2500MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_1GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_1GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_40GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_100MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_100GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_100GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_10GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_25GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_10MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_10GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_40GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_2500MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_100MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_25GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_50GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_50GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_10MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_5GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}},), is_leaf=True, yang_name="channel-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='identityref', is_config=True)
    self.__num_channels = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'port', u'breakout-mode', u'config']

  def _get_num_channels(self):
    """
    Getter method for num_channels, mapped from YANG variable /components/component/port/breakout_mode/config/num_channels (uint8)

    YANG Description: Sets the number of channels to 'breakout' on a port
capable of channelization
    """
    return self.__num_channels
      
  def _set_num_channels(self, v, load=False):
    """
    Setter method for num_channels, mapped from YANG variable /components/component/port/breakout_mode/config/num_channels (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_channels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_channels() directly.

    YANG Description: Sets the number of channels to 'breakout' on a port
capable of channelization
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_channels must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='uint8', is_config=True)""",
        })

    self.__num_channels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_channels(self):
    self.__num_channels = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='uint8', is_config=True)


  def _get_channel_speed(self):
    """
    Getter method for channel_speed, mapped from YANG variable /components/component/port/breakout_mode/config/channel_speed (identityref)

    YANG Description: Sets the channel speed on each channel -- the
supported values are defined by the
ETHERNET_SPEED identity
    """
    return self.__channel_speed
      
  def _set_channel_speed(self, v, load=False):
    """
    Setter method for channel_speed, mapped from YANG variable /components/component/port/breakout_mode/config/channel_speed (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel_speed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel_speed() directly.

    YANG Description: Sets the channel speed on each channel -- the
supported values are defined by the
ETHERNET_SPEED identity
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-eth:SPEED_5GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_2500MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_1GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_1GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_40GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_100MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_100GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_100GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_10GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_25GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_10MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_10GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_40GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_2500MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_100MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_25GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_50GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_50GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_10MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_5GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}},), is_leaf=True, yang_name="channel-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel_speed must be of a type compatible with identityref""",
          'defined-type': "openconfig-platform-port:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-eth:SPEED_5GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_2500MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_1GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_1GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_40GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_100MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_100GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_100GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_10GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_25GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_10MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_10GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_40GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_2500MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_100MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_25GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_50GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_50GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_10MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_5GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}},), is_leaf=True, yang_name="channel-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='identityref', is_config=True)""",
        })

    self.__channel_speed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel_speed(self):
    self.__channel_speed = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-eth:SPEED_5GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_2500MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_1GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_1GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_40GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_100MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_100GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_100GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_10GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_25GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_10MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_10GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_40GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_2500MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_100MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_25GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_50GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_50GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_10MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_5GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}},), is_leaf=True, yang_name="channel-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='identityref', is_config=True)

  num_channels = __builtin__.property(_get_num_channels, _set_num_channels)
  channel_speed = __builtin__.property(_get_channel_speed, _set_channel_speed)


  _pyangbind_elements = OrderedDict([('num_channels', num_channels), ('channel_speed', channel_speed), ])


class yc_state_openconfig_platform__components_component_port_breakout_mode_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/port/breakout-mode/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for port breakout
  """
  __slots__ = ('_path_helper', '_extmethods', '__num_channels','__channel_speed',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__channel_speed = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-eth:SPEED_5GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_2500MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_1GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_1GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_40GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_100MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_100GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_100GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_10GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_25GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_10MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_10GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_40GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_2500MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_100MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_25GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_50GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_50GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_10MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_5GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}},), is_leaf=True, yang_name="channel-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='identityref', is_config=False)
    self.__num_channels = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'port', u'breakout-mode', u'state']

  def _get_num_channels(self):
    """
    Getter method for num_channels, mapped from YANG variable /components/component/port/breakout_mode/state/num_channels (uint8)

    YANG Description: Sets the number of channels to 'breakout' on a port
capable of channelization
    """
    return self.__num_channels
      
  def _set_num_channels(self, v, load=False):
    """
    Setter method for num_channels, mapped from YANG variable /components/component/port/breakout_mode/state/num_channels (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_channels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_channels() directly.

    YANG Description: Sets the number of channels to 'breakout' on a port
capable of channelization
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_channels must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='uint8', is_config=False)""",
        })

    self.__num_channels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_channels(self):
    self.__num_channels = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='uint8', is_config=False)


  def _get_channel_speed(self):
    """
    Getter method for channel_speed, mapped from YANG variable /components/component/port/breakout_mode/state/channel_speed (identityref)

    YANG Description: Sets the channel speed on each channel -- the
supported values are defined by the
ETHERNET_SPEED identity
    """
    return self.__channel_speed
      
  def _set_channel_speed(self, v, load=False):
    """
    Setter method for channel_speed, mapped from YANG variable /components/component/port/breakout_mode/state/channel_speed (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel_speed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel_speed() directly.

    YANG Description: Sets the channel speed on each channel -- the
supported values are defined by the
ETHERNET_SPEED identity
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-eth:SPEED_5GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_2500MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_1GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_1GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_40GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_100MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_100GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_100GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_10GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_25GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_10MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_10GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_40GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_2500MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_100MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_25GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_50GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_50GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_10MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_5GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}},), is_leaf=True, yang_name="channel-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel_speed must be of a type compatible with identityref""",
          'defined-type': "openconfig-platform-port:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-eth:SPEED_5GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_2500MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_1GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_1GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_40GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_100MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_100GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_100GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_10GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_25GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_10MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_10GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_40GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_2500MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_100MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_25GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_50GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_50GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_10MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_5GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}},), is_leaf=True, yang_name="channel-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='identityref', is_config=False)""",
        })

    self.__channel_speed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel_speed(self):
    self.__channel_speed = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-eth:SPEED_5GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_2500MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_1GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_1GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_40GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_100MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_100GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_100GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_10GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_25GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_10MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_10GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_40GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_2500MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_100MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_25GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_50GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_UNKNOWN': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_50GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'oc-eth:SPEED_10MB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}, u'SPEED_5GB': {u'@namespace': u'http://openconfig.net/yang/interfaces/ethernet', u'@module': u'openconfig-if-ethernet'}},), is_leaf=True, yang_name="channel-speed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='identityref', is_config=False)

  num_channels = __builtin__.property(_get_num_channels)
  channel_speed = __builtin__.property(_get_channel_speed)


  _pyangbind_elements = OrderedDict([('num_channels', num_channels), ('channel_speed', channel_speed), ])


class yc_breakout_mode_openconfig_platform__components_component_port_breakout_mode(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/port/breakout-mode. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for port breakout data
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'breakout-mode'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_platform__components_component_port_breakout_mode_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_platform__components_component_port_breakout_mode_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'port', u'breakout-mode']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /components/component/port/breakout_mode/config (container)

    YANG Description: Configuration data for port breakout
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /components/component/port/breakout_mode/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for port breakout
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_platform__components_component_port_breakout_mode_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_platform__components_component_port_breakout_mode_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_platform__components_component_port_breakout_mode_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /components/component/port/breakout_mode/state (container)

    YANG Description: Operational state data for port breakout
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /components/component/port/breakout_mode/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for port breakout
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_platform__components_component_port_breakout_mode_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_platform__components_component_port_breakout_mode_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_platform__components_component_port_breakout_mode_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_port_openconfig_platform__components_component_port(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/port. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data for physical port components
  """
  __slots__ = ('_path_helper', '_extmethods', '__breakout_mode',)

  _yang_name = 'port'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__breakout_mode = YANGDynClass(base=yc_breakout_mode_openconfig_platform__components_component_port_breakout_mode, is_container='container', yang_name="breakout-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'port']

  def _get_breakout_mode(self):
    """
    Getter method for breakout_mode, mapped from YANG variable /components/component/port/breakout_mode (container)

    YANG Description: Top-level container for port breakout data
    """
    return self.__breakout_mode
      
  def _set_breakout_mode(self, v, load=False):
    """
    Setter method for breakout_mode, mapped from YANG variable /components/component/port/breakout_mode (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_breakout_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_breakout_mode() directly.

    YANG Description: Top-level container for port breakout data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_breakout_mode_openconfig_platform__components_component_port_breakout_mode, is_container='container', yang_name="breakout-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """breakout_mode must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_breakout_mode_openconfig_platform__components_component_port_breakout_mode, is_container='container', yang_name="breakout-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='container', is_config=True)""",
        })

    self.__breakout_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_breakout_mode(self):
    self.__breakout_mode = YANGDynClass(base=yc_breakout_mode_openconfig_platform__components_component_port_breakout_mode, is_container='container', yang_name="breakout-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/port', defining_module='openconfig-platform-port', yang_type='container', is_config=True)

  breakout_mode = __builtin__.property(_get_breakout_mode, _set_breakout_mode)


  _pyangbind_elements = OrderedDict([('breakout_mode', breakout_mode), ])


class yc_power_supply_openconfig_platform__components_component_power_supply(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/power-supply. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data for power supply components
  """
  _pyangbind_elements = {}

  

class yc_fan_openconfig_platform__components_component_fan(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/fan. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data for fan components
  """
  _pyangbind_elements = {}

  

class yc_fabric_openconfig_platform__components_component_fabric(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/fabric. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data for fabric components
  """
  _pyangbind_elements = {}

  

class yc_storage_openconfig_platform__components_component_storage(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/storage. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data for storage components
  """
  _pyangbind_elements = {}

  

class yc_cpu_openconfig_platform__components_component_cpu(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/cpu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data for cpu components
  """
  _pyangbind_elements = {}

  

class yc_integrated_circuit_openconfig_platform__components_component_integrated_circuit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/integrated-circuit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data for chip components, such as ASIC, NPUs, etc.
  """
  _pyangbind_elements = {}

  

class yc_backplane_openconfig_platform__components_component_backplane(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/backplane. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data for backplane components
  """
  _pyangbind_elements = {}

  

class yc_config_openconfig_platform__components_component_transceiver_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/transceiver/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for client port transceivers
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__form_factor_preconf','__ethernet_pmd_preconf','__fec_mode',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__fec_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:FEC_ENABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_AUTO': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_ENABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FEC_DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FEC_AUTO': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},), is_leaf=True, yang_name="fec-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=True)
    self.__form_factor_preconf = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="form-factor-preconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='boolean', is_config=True)
    self.__ethernet_pmd_preconf = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="ethernet-pmd-preconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'transceiver', u'config']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /components/component/transceiver/config/enabled (boolean)

    YANG Description: Turns power on / off to the transceiver -- provides a means
to power on/off the transceiver (in the case of SFP, SFP+,
QSFP,...) or enable high-power mode (in the case of CFP,
CFP2, CFP4) and is optionally supported (device can choose to
always enable).  True = power on / high power, False =
powered off
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /components/component/transceiver/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Turns power on / off to the transceiver -- provides a means
to power on/off the transceiver (in the case of SFP, SFP+,
QSFP,...) or enable high-power mode (in the case of CFP,
CFP2, CFP4) and is optionally supported (device can choose to
always enable).  True = power on / high power, False =
powered off
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='boolean', is_config=True)


  def _get_form_factor_preconf(self):
    """
    Getter method for form_factor_preconf, mapped from YANG variable /components/component/transceiver/config/form_factor_preconf (identityref)

    YANG Description: Indicates the type of optical transceiver used on this
port.  If the client port is built into the device and not
pluggable, then non-pluggable is the corresponding state. If
a device port supports multiple form factors (e.g. QSFP28
and QSFP+, then the value of the transceiver installed shall
be reported. If no transceiver is present, then the value of
the highest rate form factor shall be reported
(QSFP28, for example).

The form factor is included in configuration data to allow
pre-configuring a device with the expected type of
transceiver ahead of deployment.  The corresponding state
leaf should reflect the actual transceiver type plugged into
the system.
    """
    return self.__form_factor_preconf
      
  def _set_form_factor_preconf(self, v, load=False):
    """
    Setter method for form_factor_preconf, mapped from YANG variable /components/component/transceiver/config/form_factor_preconf (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_form_factor_preconf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_form_factor_preconf() directly.

    YANG Description: Indicates the type of optical transceiver used on this
port.  If the client port is built into the device and not
pluggable, then non-pluggable is the corresponding state. If
a device port supports multiple form factors (e.g. QSFP28
and QSFP+, then the value of the transceiver installed shall
be reported. If no transceiver is present, then the value of
the highest rate form factor shall be reported
(QSFP28, for example).

The form factor is included in configuration data to allow
pre-configuring a device with the expected type of
transceiver ahead of deployment.  The corresponding state
leaf should reflect the actual transceiver type plugged into
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="form-factor-preconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """form_factor_preconf must be of a type compatible with identityref""",
          'defined-type': "openconfig-platform-transceiver:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="form-factor-preconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=True)""",
        })

    self.__form_factor_preconf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_form_factor_preconf(self):
    self.__form_factor_preconf = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="form-factor-preconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=True)


  def _get_ethernet_pmd_preconf(self):
    """
    Getter method for ethernet_pmd_preconf, mapped from YANG variable /components/component/transceiver/config/ethernet_pmd_preconf (identityref)

    YANG Description: The Ethernet PMD is a property of the optical transceiver
used on the port, indicating the type of physical connection.
It is included in configuration data to allow pre-configuring
a port/transceiver with the expected PMD.  The actual PMD is
indicated by the ethernet-pmd state leaf.
    """
    return self.__ethernet_pmd_preconf
      
  def _set_ethernet_pmd_preconf(self, v, load=False):
    """
    Setter method for ethernet_pmd_preconf, mapped from YANG variable /components/component/transceiver/config/ethernet_pmd_preconf (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ethernet_pmd_preconf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ethernet_pmd_preconf() directly.

    YANG Description: The Ethernet PMD is a property of the optical transceiver
used on the port, indicating the type of physical connection.
It is included in configuration data to allow pre-configuring
a port/transceiver with the expected PMD.  The actual PMD is
indicated by the ethernet-pmd state leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="ethernet-pmd-preconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ethernet_pmd_preconf must be of a type compatible with identityref""",
          'defined-type': "openconfig-platform-transceiver:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="ethernet-pmd-preconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=True)""",
        })

    self.__ethernet_pmd_preconf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ethernet_pmd_preconf(self):
    self.__ethernet_pmd_preconf = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="ethernet-pmd-preconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=True)


  def _get_fec_mode(self):
    """
    Getter method for fec_mode, mapped from YANG variable /components/component/transceiver/config/fec_mode (identityref)

    YANG Description: The FEC mode indicates the mode of operation for the
transceiver's FEC. This defines typical operational modes
and does not aim to specify more granular FEC capabilities.
    """
    return self.__fec_mode
      
  def _set_fec_mode(self, v, load=False):
    """
    Setter method for fec_mode, mapped from YANG variable /components/component/transceiver/config/fec_mode (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_mode() directly.

    YANG Description: The FEC mode indicates the mode of operation for the
transceiver's FEC. This defines typical operational modes
and does not aim to specify more granular FEC capabilities.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:FEC_ENABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_AUTO': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_ENABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FEC_DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FEC_AUTO': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},), is_leaf=True, yang_name="fec-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_mode must be of a type compatible with identityref""",
          'defined-type': "openconfig-platform-transceiver:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:FEC_ENABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_AUTO': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_ENABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FEC_DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FEC_AUTO': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},), is_leaf=True, yang_name="fec-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=True)""",
        })

    self.__fec_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_mode(self):
    self.__fec_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:FEC_ENABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_AUTO': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_ENABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FEC_DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FEC_AUTO': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},), is_leaf=True, yang_name="fec-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  form_factor_preconf = __builtin__.property(_get_form_factor_preconf, _set_form_factor_preconf)
  ethernet_pmd_preconf = __builtin__.property(_get_ethernet_pmd_preconf, _set_ethernet_pmd_preconf)
  fec_mode = __builtin__.property(_get_fec_mode, _set_fec_mode)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('form_factor_preconf', form_factor_preconf), ('ethernet_pmd_preconf', ethernet_pmd_preconf), ('fec_mode', fec_mode), ])


class yc_pre_fec_ber_openconfig_platform__components_component_transceiver_state_pre_fec_ber(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/transceiver/state/pre-fec-ber. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Bit error rate before forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'pre-fec-ber'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'transceiver', u'state', u'pre-fec-ber']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /components/component/transceiver/state/pre_fec_ber/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /components/component/transceiver/state/pre_fec_ber/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /components/component/transceiver/state/pre_fec_ber/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /components/component/transceiver/state/pre_fec_ber/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /components/component/transceiver/state/pre_fec_ber/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /components/component/transceiver/state/pre_fec_ber/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /components/component/transceiver/state/pre_fec_ber/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /components/component/transceiver/state/pre_fec_ber/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /components/component/transceiver/state/pre_fec_ber/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /components/component/transceiver/state/pre_fec_ber/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /components/component/transceiver/state/pre_fec_ber/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /components/component/transceiver/state/pre_fec_ber/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /components/component/transceiver/state/pre_fec_ber/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /components/component/transceiver/state/pre_fec_ber/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_post_fec_ber_openconfig_platform__components_component_transceiver_state_post_fec_ber(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/transceiver/state/post-fec-ber. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Bit error rate after forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'post-fec-ber'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'transceiver', u'state', u'post-fec-ber']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /components/component/transceiver/state/post_fec_ber/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /components/component/transceiver/state/post_fec_ber/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /components/component/transceiver/state/post_fec_ber/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /components/component/transceiver/state/post_fec_ber/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /components/component/transceiver/state/post_fec_ber/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /components/component/transceiver/state/post_fec_ber/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /components/component/transceiver/state/post_fec_ber/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /components/component/transceiver/state/post_fec_ber/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /components/component/transceiver/state/post_fec_ber/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /components/component/transceiver/state/post_fec_ber/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /components/component/transceiver/state/post_fec_ber/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /components/component/transceiver/state/post_fec_ber/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /components/component/transceiver/state/post_fec_ber/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /components/component/transceiver/state/post_fec_ber/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_output_power_openconfig_platform__components_component_transceiver_state_output_power(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/transceiver/state/output-power. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The output optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'output-power'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'transceiver', u'state', u'output-power']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /components/component/transceiver/state/output_power/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /components/component/transceiver/state/output_power/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /components/component/transceiver/state/output_power/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /components/component/transceiver/state/output_power/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /components/component/transceiver/state/output_power/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /components/component/transceiver/state/output_power/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /components/component/transceiver/state/output_power/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /components/component/transceiver/state/output_power/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /components/component/transceiver/state/output_power/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /components/component/transceiver/state/output_power/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /components/component/transceiver/state/output_power/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /components/component/transceiver/state/output_power/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /components/component/transceiver/state/output_power/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /components/component/transceiver/state/output_power/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_input_power_openconfig_platform__components_component_transceiver_state_input_power(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/transceiver/state/input-power. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The input optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'input-power'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'transceiver', u'state', u'input-power']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /components/component/transceiver/state/input_power/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /components/component/transceiver/state/input_power/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /components/component/transceiver/state/input_power/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /components/component/transceiver/state/input_power/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /components/component/transceiver/state/input_power/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /components/component/transceiver/state/input_power/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /components/component/transceiver/state/input_power/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /components/component/transceiver/state/input_power/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /components/component/transceiver/state/input_power/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /components/component/transceiver/state/input_power/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /components/component/transceiver/state/input_power/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /components/component/transceiver/state/input_power/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /components/component/transceiver/state/input_power/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /components/component/transceiver/state/input_power/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_laser_bias_current_openconfig_platform__components_component_transceiver_state_laser_bias_current(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/transceiver/state/laser-bias-current. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'laser-bias-current'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'transceiver', u'state', u'laser-bias-current']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /components/component/transceiver/state/laser_bias_current/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /components/component/transceiver/state/laser_bias_current/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /components/component/transceiver/state/laser_bias_current/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /components/component/transceiver/state/laser_bias_current/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /components/component/transceiver/state/laser_bias_current/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /components/component/transceiver/state/laser_bias_current/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /components/component/transceiver/state/laser_bias_current/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /components/component/transceiver/state/laser_bias_current/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /components/component/transceiver/state/laser_bias_current/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /components/component/transceiver/state/laser_bias_current/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /components/component/transceiver/state/laser_bias_current/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /components/component/transceiver/state/laser_bias_current/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /components/component/transceiver/state/laser_bias_current/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /components/component/transceiver/state/laser_bias_current/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_state_openconfig_platform__components_component_transceiver_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/transceiver/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for client port transceivers
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__form_factor_preconf','__ethernet_pmd_preconf','__fec_mode','__present','__form_factor','__connector_type','__vendor','__vendor_part','__vendor_rev','__ethernet_pmd','__sonet_sdh_compliance_code','__otn_compliance_code','__serial_no','__date_code','__fault_condition','__fec_status','__fec_uncorrectable_blocks','__fec_uncorrectable_words','__fec_corrected_bytes','__fec_corrected_bits','__pre_fec_ber','__post_fec_ber','__output_power','__input_power','__laser_bias_current',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__fec_corrected_bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='yang:counter64', is_config=False)
    self.__serial_no = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..16']}), is_leaf=True, yang_name="serial-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=False)
    self.__vendor_rev = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..2']}), is_leaf=True, yang_name="vendor-rev", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=False)
    self.__form_factor = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="form-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)
    self.__output_power = YANGDynClass(base=yc_output_power_openconfig_platform__components_component_transceiver_state_output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)
    self.__fec_corrected_bits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='yang:counter64', is_config=False)
    self.__fec_uncorrectable_words = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-words", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='yang:counter64', is_config=False)
    self.__pre_fec_ber = YANGDynClass(base=yc_pre_fec_ber_openconfig_platform__components_component_transceiver_state_pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)
    self.__date_code = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9]{4}\\-[0-9]{2}\\-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(\\.[0-9]+)?Z[+-][0-9]{2}:[0-9]{2}$'}), is_leaf=True, yang_name="date-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-yang:date-and-time', is_config=False)
    self.__present = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NOT_PRESENT': {}, u'PRESENT': {}},), is_leaf=True, yang_name="present", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='enumeration', is_config=False)
    self.__ethernet_pmd_preconf = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="ethernet-pmd-preconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)
    self.__fault_condition = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fault-condition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='boolean', is_config=False)
    self.__fec_uncorrectable_blocks = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='yang:counter64', is_config=False)
    self.__vendor = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..16']}), is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=False)
    self.__otn_compliance_code = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:P1L1_2D2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:P1L1_2D1': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'P1L1_2D2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'P1L1_2D1': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'OTN_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:P1S1_2D2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:OTN_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'P1S1_2D2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="otn-compliance-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)
    self.__laser_bias_current = YANGDynClass(base=yc_laser_bias_current_openconfig_platform__components_component_transceiver_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)
    self.__ethernet_pmd = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="ethernet-pmd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)
    self.__form_factor_preconf = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="form-factor-preconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)
    self.__fec_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:FEC_STATUS_UNLOCKED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_STATUS_LOCKED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_STATUS_UNLOCKED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FEC_STATUS_LOCKED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},), is_leaf=True, yang_name="fec-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)
    self.__post_fec_ber = YANGDynClass(base=yc_post_fec_ber_openconfig_platform__components_component_transceiver_state_post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)
    self.__fec_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:FEC_ENABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_AUTO': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_ENABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FEC_DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FEC_AUTO': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},), is_leaf=True, yang_name="fec-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='boolean', is_config=False)
    self.__connector_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:MPO_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'MPO_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:LC_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SC_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SC_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'LC_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="connector-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)
    self.__vendor_part = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..16']}), is_leaf=True, yang_name="vendor-part", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=False)
    self.__input_power = YANGDynClass(base=yc_input_power_openconfig_platform__components_component_transceiver_state_input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)
    self.__sonet_sdh_compliance_code = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:VSR2000_3R2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'VSR2000_3R2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:VSR2000_3R3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SONET_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SONET_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'VSR2000_3R3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'VSR2000_3R5': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:VSR2000_3R5': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="sonet-sdh-compliance-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'transceiver', u'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /components/component/transceiver/state/enabled (boolean)

    YANG Description: Turns power on / off to the transceiver -- provides a means
to power on/off the transceiver (in the case of SFP, SFP+,
QSFP,...) or enable high-power mode (in the case of CFP,
CFP2, CFP4) and is optionally supported (device can choose to
always enable).  True = power on / high power, False =
powered off
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /components/component/transceiver/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Turns power on / off to the transceiver -- provides a means
to power on/off the transceiver (in the case of SFP, SFP+,
QSFP,...) or enable high-power mode (in the case of CFP,
CFP2, CFP4) and is optionally supported (device can choose to
always enable).  True = power on / high power, False =
powered off
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='boolean', is_config=False)


  def _get_form_factor_preconf(self):
    """
    Getter method for form_factor_preconf, mapped from YANG variable /components/component/transceiver/state/form_factor_preconf (identityref)

    YANG Description: Indicates the type of optical transceiver used on this
port.  If the client port is built into the device and not
pluggable, then non-pluggable is the corresponding state. If
a device port supports multiple form factors (e.g. QSFP28
and QSFP+, then the value of the transceiver installed shall
be reported. If no transceiver is present, then the value of
the highest rate form factor shall be reported
(QSFP28, for example).

The form factor is included in configuration data to allow
pre-configuring a device with the expected type of
transceiver ahead of deployment.  The corresponding state
leaf should reflect the actual transceiver type plugged into
the system.
    """
    return self.__form_factor_preconf
      
  def _set_form_factor_preconf(self, v, load=False):
    """
    Setter method for form_factor_preconf, mapped from YANG variable /components/component/transceiver/state/form_factor_preconf (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_form_factor_preconf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_form_factor_preconf() directly.

    YANG Description: Indicates the type of optical transceiver used on this
port.  If the client port is built into the device and not
pluggable, then non-pluggable is the corresponding state. If
a device port supports multiple form factors (e.g. QSFP28
and QSFP+, then the value of the transceiver installed shall
be reported. If no transceiver is present, then the value of
the highest rate form factor shall be reported
(QSFP28, for example).

The form factor is included in configuration data to allow
pre-configuring a device with the expected type of
transceiver ahead of deployment.  The corresponding state
leaf should reflect the actual transceiver type plugged into
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="form-factor-preconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """form_factor_preconf must be of a type compatible with identityref""",
          'defined-type': "openconfig-platform-transceiver:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="form-factor-preconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)""",
        })

    self.__form_factor_preconf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_form_factor_preconf(self):
    self.__form_factor_preconf = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="form-factor-preconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)


  def _get_ethernet_pmd_preconf(self):
    """
    Getter method for ethernet_pmd_preconf, mapped from YANG variable /components/component/transceiver/state/ethernet_pmd_preconf (identityref)

    YANG Description: The Ethernet PMD is a property of the optical transceiver
used on the port, indicating the type of physical connection.
It is included in configuration data to allow pre-configuring
a port/transceiver with the expected PMD.  The actual PMD is
indicated by the ethernet-pmd state leaf.
    """
    return self.__ethernet_pmd_preconf
      
  def _set_ethernet_pmd_preconf(self, v, load=False):
    """
    Setter method for ethernet_pmd_preconf, mapped from YANG variable /components/component/transceiver/state/ethernet_pmd_preconf (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ethernet_pmd_preconf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ethernet_pmd_preconf() directly.

    YANG Description: The Ethernet PMD is a property of the optical transceiver
used on the port, indicating the type of physical connection.
It is included in configuration data to allow pre-configuring
a port/transceiver with the expected PMD.  The actual PMD is
indicated by the ethernet-pmd state leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="ethernet-pmd-preconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ethernet_pmd_preconf must be of a type compatible with identityref""",
          'defined-type': "openconfig-platform-transceiver:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="ethernet-pmd-preconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)""",
        })

    self.__ethernet_pmd_preconf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ethernet_pmd_preconf(self):
    self.__ethernet_pmd_preconf = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="ethernet-pmd-preconf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)


  def _get_fec_mode(self):
    """
    Getter method for fec_mode, mapped from YANG variable /components/component/transceiver/state/fec_mode (identityref)

    YANG Description: The FEC mode indicates the mode of operation for the
transceiver's FEC. This defines typical operational modes
and does not aim to specify more granular FEC capabilities.
    """
    return self.__fec_mode
      
  def _set_fec_mode(self, v, load=False):
    """
    Setter method for fec_mode, mapped from YANG variable /components/component/transceiver/state/fec_mode (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_mode() directly.

    YANG Description: The FEC mode indicates the mode of operation for the
transceiver's FEC. This defines typical operational modes
and does not aim to specify more granular FEC capabilities.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:FEC_ENABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_AUTO': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_ENABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FEC_DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FEC_AUTO': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},), is_leaf=True, yang_name="fec-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_mode must be of a type compatible with identityref""",
          'defined-type': "openconfig-platform-transceiver:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:FEC_ENABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_AUTO': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_ENABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FEC_DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FEC_AUTO': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},), is_leaf=True, yang_name="fec-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)""",
        })

    self.__fec_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_mode(self):
    self.__fec_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:FEC_ENABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_AUTO': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_ENABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FEC_DISABLED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FEC_AUTO': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},), is_leaf=True, yang_name="fec-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)


  def _get_present(self):
    """
    Getter method for present, mapped from YANG variable /components/component/transceiver/state/present (enumeration)

    YANG Description: Indicates whether a transceiver is present in
the specified client port.
    """
    return self.__present
      
  def _set_present(self, v, load=False):
    """
    Setter method for present, mapped from YANG variable /components/component/transceiver/state/present (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_present is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_present() directly.

    YANG Description: Indicates whether a transceiver is present in
the specified client port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NOT_PRESENT': {}, u'PRESENT': {}},), is_leaf=True, yang_name="present", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """present must be of a type compatible with enumeration""",
          'defined-type': "openconfig-platform-transceiver:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NOT_PRESENT': {}, u'PRESENT': {}},), is_leaf=True, yang_name="present", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='enumeration', is_config=False)""",
        })

    self.__present = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_present(self):
    self.__present = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'NOT_PRESENT': {}, u'PRESENT': {}},), is_leaf=True, yang_name="present", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='enumeration', is_config=False)


  def _get_form_factor(self):
    """
    Getter method for form_factor, mapped from YANG variable /components/component/transceiver/state/form_factor (identityref)

    YANG Description: Indicates the type of optical transceiver used on this
port.  If the client port is built into the device and not
pluggable, then non-pluggable is the corresponding state. If
a device port supports multiple form factors (e.g. QSFP28
and QSFP+, then the value of the transceiver installed shall
be reported. If no transceiver is present, then the value of
the highest rate form factor shall be reported
(QSFP28, for example).
    """
    return self.__form_factor
      
  def _set_form_factor(self, v, load=False):
    """
    Setter method for form_factor, mapped from YANG variable /components/component/transceiver/state/form_factor (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_form_factor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_form_factor() directly.

    YANG Description: Indicates the type of optical transceiver used on this
port.  If the client port is built into the device and not
pluggable, then non-pluggable is the corresponding state. If
a device port supports multiple form factors (e.g. QSFP28
and QSFP+, then the value of the transceiver installed shall
be reported. If no transceiver is present, then the value of
the highest rate form factor shall be reported
(QSFP28, for example).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="form-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """form_factor must be of a type compatible with identityref""",
          'defined-type': "openconfig-platform-transceiver:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="form-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)""",
        })

    self.__form_factor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_form_factor(self):
    self.__form_factor = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP28': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP2_ACO': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CPAK': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'NON_PLUGGABLE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'XFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:X2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:OTHER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'QSFP_PLUS': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CFP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="form-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)


  def _get_connector_type(self):
    """
    Getter method for connector_type, mapped from YANG variable /components/component/transceiver/state/connector_type (identityref)

    YANG Description: Connector type used on this port
    """
    return self.__connector_type
      
  def _set_connector_type(self, v, load=False):
    """
    Setter method for connector_type, mapped from YANG variable /components/component/transceiver/state/connector_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connector_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connector_type() directly.

    YANG Description: Connector type used on this port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:MPO_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'MPO_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:LC_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SC_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SC_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'LC_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="connector-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connector_type must be of a type compatible with identityref""",
          'defined-type': "openconfig-platform-transceiver:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:MPO_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'MPO_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:LC_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SC_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SC_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'LC_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="connector-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)""",
        })

    self.__connector_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connector_type(self):
    self.__connector_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:MPO_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'MPO_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:LC_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SC_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SC_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'LC_CONNECTOR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="connector-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)


  def _get_vendor(self):
    """
    Getter method for vendor, mapped from YANG variable /components/component/transceiver/state/vendor (string)

    YANG Description: Full name of transceiver vendor. 16-octet field that
contains ASCII characters, left-aligned and padded on the
right with ASCII spaces (20h)
    """
    return self.__vendor
      
  def _set_vendor(self, v, load=False):
    """
    Setter method for vendor, mapped from YANG variable /components/component/transceiver/state/vendor (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendor() directly.

    YANG Description: Full name of transceiver vendor. 16-octet field that
contains ASCII characters, left-aligned and padded on the
right with ASCII spaces (20h)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..16']}), is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vendor must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..16']}), is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=False)""",
        })

    self.__vendor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vendor(self):
    self.__vendor = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..16']}), is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=False)


  def _get_vendor_part(self):
    """
    Getter method for vendor_part, mapped from YANG variable /components/component/transceiver/state/vendor_part (string)

    YANG Description: Transceiver vendor's part number. 16-octet field that
contains ASCII characters, left-aligned and padded on the
right with ASCII spaces (20h). If part number is undefined,
all 16 octets = 0h
    """
    return self.__vendor_part
      
  def _set_vendor_part(self, v, load=False):
    """
    Setter method for vendor_part, mapped from YANG variable /components/component/transceiver/state/vendor_part (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendor_part is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendor_part() directly.

    YANG Description: Transceiver vendor's part number. 16-octet field that
contains ASCII characters, left-aligned and padded on the
right with ASCII spaces (20h). If part number is undefined,
all 16 octets = 0h
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..16']}), is_leaf=True, yang_name="vendor-part", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vendor_part must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..16']}), is_leaf=True, yang_name="vendor-part", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=False)""",
        })

    self.__vendor_part = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vendor_part(self):
    self.__vendor_part = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..16']}), is_leaf=True, yang_name="vendor-part", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=False)


  def _get_vendor_rev(self):
    """
    Getter method for vendor_rev, mapped from YANG variable /components/component/transceiver/state/vendor_rev (string)

    YANG Description: Transceiver vendor's revision number. 2-octet field that
contains ASCII characters, left-aligned and padded on the
right with ASCII spaces (20h)
    """
    return self.__vendor_rev
      
  def _set_vendor_rev(self, v, load=False):
    """
    Setter method for vendor_rev, mapped from YANG variable /components/component/transceiver/state/vendor_rev (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendor_rev is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendor_rev() directly.

    YANG Description: Transceiver vendor's revision number. 2-octet field that
contains ASCII characters, left-aligned and padded on the
right with ASCII spaces (20h)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..2']}), is_leaf=True, yang_name="vendor-rev", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vendor_rev must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..2']}), is_leaf=True, yang_name="vendor-rev", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=False)""",
        })

    self.__vendor_rev = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vendor_rev(self):
    self.__vendor_rev = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..2']}), is_leaf=True, yang_name="vendor-rev", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=False)


  def _get_ethernet_pmd(self):
    """
    Getter method for ethernet_pmd, mapped from YANG variable /components/component/transceiver/state/ethernet_pmd (identityref)

    YANG Description: Ethernet PMD (physical medium dependent sublayer) that the
transceiver supports. The SFF/QSFP MSAs have registers for
this and CFP MSA has similar.
    """
    return self.__ethernet_pmd
      
  def _set_ethernet_pmd(self, v, load=False):
    """
    Setter method for ethernet_pmd, mapped from YANG variable /components/component/transceiver/state/ethernet_pmd (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ethernet_pmd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ethernet_pmd() directly.

    YANG Description: Ethernet PMD (physical medium dependent sublayer) that the
transceiver supports. The SFF/QSFP MSAs have registers for
this and CFP MSA has similar.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="ethernet-pmd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ethernet_pmd must be of a type compatible with identityref""",
          'defined-type': "openconfig-platform-transceiver:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="ethernet-pmd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)""",
        })

    self.__ethernet_pmd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ethernet_pmd(self):
    self.__ethernet_pmd = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_AOC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100G_ACC': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ZR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_10GBASE_LR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR10': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_4X10GBASE_SR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_ER': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_10GBASE_LRM': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_40GBASE_LR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_CWDM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_PSM4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_40GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_100GBASE_SR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_ER4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CLR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:ETH_100GBASE_CR4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'ETH_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="ethernet-pmd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)


  def _get_sonet_sdh_compliance_code(self):
    """
    Getter method for sonet_sdh_compliance_code, mapped from YANG variable /components/component/transceiver/state/sonet_sdh_compliance_code (identityref)

    YANG Description: SONET/SDH application code supported by the port
    """
    return self.__sonet_sdh_compliance_code
      
  def _set_sonet_sdh_compliance_code(self, v, load=False):
    """
    Setter method for sonet_sdh_compliance_code, mapped from YANG variable /components/component/transceiver/state/sonet_sdh_compliance_code (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sonet_sdh_compliance_code is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sonet_sdh_compliance_code() directly.

    YANG Description: SONET/SDH application code supported by the port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:VSR2000_3R2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'VSR2000_3R2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:VSR2000_3R3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SONET_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SONET_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'VSR2000_3R3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'VSR2000_3R5': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:VSR2000_3R5': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="sonet-sdh-compliance-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sonet_sdh_compliance_code must be of a type compatible with identityref""",
          'defined-type': "openconfig-platform-transceiver:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:VSR2000_3R2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'VSR2000_3R2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:VSR2000_3R3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SONET_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SONET_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'VSR2000_3R3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'VSR2000_3R5': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:VSR2000_3R5': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="sonet-sdh-compliance-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)""",
        })

    self.__sonet_sdh_compliance_code = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sonet_sdh_compliance_code(self):
    self.__sonet_sdh_compliance_code = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:VSR2000_3R2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'VSR2000_3R2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:VSR2000_3R3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'SONET_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:SONET_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'VSR2000_3R3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'VSR2000_3R5': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:VSR2000_3R5': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="sonet-sdh-compliance-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)


  def _get_otn_compliance_code(self):
    """
    Getter method for otn_compliance_code, mapped from YANG variable /components/component/transceiver/state/otn_compliance_code (identityref)

    YANG Description: OTN application code supported by the port
    """
    return self.__otn_compliance_code
      
  def _set_otn_compliance_code(self, v, load=False):
    """
    Setter method for otn_compliance_code, mapped from YANG variable /components/component/transceiver/state/otn_compliance_code (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_otn_compliance_code is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_otn_compliance_code() directly.

    YANG Description: OTN application code supported by the port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:P1L1_2D2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:P1L1_2D1': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'P1L1_2D2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'P1L1_2D1': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'OTN_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:P1S1_2D2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:OTN_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'P1S1_2D2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="otn-compliance-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """otn_compliance_code must be of a type compatible with identityref""",
          'defined-type': "openconfig-platform-transceiver:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:P1L1_2D2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:P1L1_2D1': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'P1L1_2D2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'P1L1_2D1': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'OTN_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:P1S1_2D2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:OTN_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'P1S1_2D2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="otn-compliance-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)""",
        })

    self.__otn_compliance_code = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_otn_compliance_code(self):
    self.__otn_compliance_code = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:P1L1_2D2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:P1L1_2D1': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'P1L1_2D2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'P1L1_2D1': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'OTN_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:P1S1_2D2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:OTN_UNDEFINED': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'P1S1_2D2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="otn-compliance-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)


  def _get_serial_no(self):
    """
    Getter method for serial_no, mapped from YANG variable /components/component/transceiver/state/serial_no (string)

    YANG Description: Transceiver serial number. 16-octet field that contains
ASCII characters, left-aligned and padded on the right with
ASCII spaces (20h). If part serial number is undefined, all
16 octets = 0h
    """
    return self.__serial_no
      
  def _set_serial_no(self, v, load=False):
    """
    Setter method for serial_no, mapped from YANG variable /components/component/transceiver/state/serial_no (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serial_no is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serial_no() directly.

    YANG Description: Transceiver serial number. 16-octet field that contains
ASCII characters, left-aligned and padded on the right with
ASCII spaces (20h). If part serial number is undefined, all
16 octets = 0h
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..16']}), is_leaf=True, yang_name="serial-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serial_no must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..16']}), is_leaf=True, yang_name="serial-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=False)""",
        })

    self.__serial_no = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serial_no(self):
    self.__serial_no = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'1..16']}), is_leaf=True, yang_name="serial-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=False)


  def _get_date_code(self):
    """
    Getter method for date_code, mapped from YANG variable /components/component/transceiver/state/date_code (oc-yang:date-and-time)

    YANG Description: Representation of the transceiver date code, typically
stored as YYMMDD.  The time portion of the value is
undefined and not intended to be read.
    """
    return self.__date_code
      
  def _set_date_code(self, v, load=False):
    """
    Setter method for date_code, mapped from YANG variable /components/component/transceiver/state/date_code (oc-yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_date_code is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_date_code() directly.

    YANG Description: Representation of the transceiver date code, typically
stored as YYMMDD.  The time portion of the value is
undefined and not intended to be read.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9]{4}\\-[0-9]{2}\\-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(\\.[0-9]+)?Z[+-][0-9]{2}:[0-9]{2}$'}), is_leaf=True, yang_name="date-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """date_code must be of a type compatible with oc-yang:date-and-time""",
          'defined-type': "oc-yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9]{4}\\-[0-9]{2}\\-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(\\.[0-9]+)?Z[+-][0-9]{2}:[0-9]{2}$'}), is_leaf=True, yang_name="date-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-yang:date-and-time', is_config=False)""",
        })

    self.__date_code = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_date_code(self):
    self.__date_code = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9]{4}\\-[0-9]{2}\\-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(\\.[0-9]+)?Z[+-][0-9]{2}:[0-9]{2}$'}), is_leaf=True, yang_name="date-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-yang:date-and-time', is_config=False)


  def _get_fault_condition(self):
    """
    Getter method for fault_condition, mapped from YANG variable /components/component/transceiver/state/fault_condition (boolean)

    YANG Description: Indicates if a fault condition exists in the transceiver
    """
    return self.__fault_condition
      
  def _set_fault_condition(self, v, load=False):
    """
    Setter method for fault_condition, mapped from YANG variable /components/component/transceiver/state/fault_condition (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fault_condition is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fault_condition() directly.

    YANG Description: Indicates if a fault condition exists in the transceiver
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="fault-condition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fault_condition must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fault-condition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='boolean', is_config=False)""",
        })

    self.__fault_condition = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fault_condition(self):
    self.__fault_condition = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fault-condition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='boolean', is_config=False)


  def _get_fec_status(self):
    """
    Getter method for fec_status, mapped from YANG variable /components/component/transceiver/state/fec_status (identityref)

    YANG Description: Operational status of FEC
    """
    return self.__fec_status
      
  def _set_fec_status(self, v, load=False):
    """
    Setter method for fec_status, mapped from YANG variable /components/component/transceiver/state/fec_status (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_status() directly.

    YANG Description: Operational status of FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:FEC_STATUS_UNLOCKED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_STATUS_LOCKED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_STATUS_UNLOCKED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FEC_STATUS_LOCKED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},), is_leaf=True, yang_name="fec-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_status must be of a type compatible with identityref""",
          'defined-type': "openconfig-platform-transceiver:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:FEC_STATUS_UNLOCKED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_STATUS_LOCKED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_STATUS_UNLOCKED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FEC_STATUS_LOCKED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},), is_leaf=True, yang_name="fec-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)""",
        })

    self.__fec_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_status(self):
    self.__fec_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-platform-types:FEC_STATUS_UNLOCKED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_STATUS_LOCKED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'FEC_STATUS_UNLOCKED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}, u'oc-platform-types:FEC_STATUS_LOCKED': {u'@namespace': u'http://openconfig.net/yang/platform-types', u'@module': u'openconfig-platform-types'}},), is_leaf=True, yang_name="fec-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='identityref', is_config=False)


  def _get_fec_uncorrectable_blocks(self):
    """
    Getter method for fec_uncorrectable_blocks, mapped from YANG variable /components/component/transceiver/state/fec_uncorrectable_blocks (yang:counter64)

    YANG Description: The number of blocks that were uncorrectable by the FEC
    """
    return self.__fec_uncorrectable_blocks
      
  def _set_fec_uncorrectable_blocks(self, v, load=False):
    """
    Setter method for fec_uncorrectable_blocks, mapped from YANG variable /components/component/transceiver/state/fec_uncorrectable_blocks (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_uncorrectable_blocks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_uncorrectable_blocks() directly.

    YANG Description: The number of blocks that were uncorrectable by the FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_uncorrectable_blocks must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='yang:counter64', is_config=False)""",
        })

    self.__fec_uncorrectable_blocks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_uncorrectable_blocks(self):
    self.__fec_uncorrectable_blocks = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='yang:counter64', is_config=False)


  def _get_fec_uncorrectable_words(self):
    """
    Getter method for fec_uncorrectable_words, mapped from YANG variable /components/component/transceiver/state/fec_uncorrectable_words (yang:counter64)

    YANG Description: The number of words that were uncorrectable by the FEC
    """
    return self.__fec_uncorrectable_words
      
  def _set_fec_uncorrectable_words(self, v, load=False):
    """
    Setter method for fec_uncorrectable_words, mapped from YANG variable /components/component/transceiver/state/fec_uncorrectable_words (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_uncorrectable_words is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_uncorrectable_words() directly.

    YANG Description: The number of words that were uncorrectable by the FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-words", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_uncorrectable_words must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-words", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='yang:counter64', is_config=False)""",
        })

    self.__fec_uncorrectable_words = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_uncorrectable_words(self):
    self.__fec_uncorrectable_words = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-words", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='yang:counter64', is_config=False)


  def _get_fec_corrected_bytes(self):
    """
    Getter method for fec_corrected_bytes, mapped from YANG variable /components/component/transceiver/state/fec_corrected_bytes (yang:counter64)

    YANG Description: The number of bytes that were corrected by the FEC
    """
    return self.__fec_corrected_bytes
      
  def _set_fec_corrected_bytes(self, v, load=False):
    """
    Setter method for fec_corrected_bytes, mapped from YANG variable /components/component/transceiver/state/fec_corrected_bytes (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_corrected_bytes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_corrected_bytes() directly.

    YANG Description: The number of bytes that were corrected by the FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_corrected_bytes must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='yang:counter64', is_config=False)""",
        })

    self.__fec_corrected_bytes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_corrected_bytes(self):
    self.__fec_corrected_bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='yang:counter64', is_config=False)


  def _get_fec_corrected_bits(self):
    """
    Getter method for fec_corrected_bits, mapped from YANG variable /components/component/transceiver/state/fec_corrected_bits (yang:counter64)

    YANG Description: The number of bits that were corrected by the FEC
    """
    return self.__fec_corrected_bits
      
  def _set_fec_corrected_bits(self, v, load=False):
    """
    Setter method for fec_corrected_bits, mapped from YANG variable /components/component/transceiver/state/fec_corrected_bits (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_corrected_bits is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_corrected_bits() directly.

    YANG Description: The number of bits that were corrected by the FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_corrected_bits must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='yang:counter64', is_config=False)""",
        })

    self.__fec_corrected_bits = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_corrected_bits(self):
    self.__fec_corrected_bits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='yang:counter64', is_config=False)


  def _get_pre_fec_ber(self):
    """
    Getter method for pre_fec_ber, mapped from YANG variable /components/component/transceiver/state/pre_fec_ber (container)

    YANG Description: Bit error rate before forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__pre_fec_ber
      
  def _set_pre_fec_ber(self, v, load=False):
    """
    Setter method for pre_fec_ber, mapped from YANG variable /components/component/transceiver/state/pre_fec_ber (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pre_fec_ber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pre_fec_ber() directly.

    YANG Description: Bit error rate before forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_pre_fec_ber_openconfig_platform__components_component_transceiver_state_pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pre_fec_ber must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_pre_fec_ber_openconfig_platform__components_component_transceiver_state_pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)""",
        })

    self.__pre_fec_ber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pre_fec_ber(self):
    self.__pre_fec_ber = YANGDynClass(base=yc_pre_fec_ber_openconfig_platform__components_component_transceiver_state_pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)


  def _get_post_fec_ber(self):
    """
    Getter method for post_fec_ber, mapped from YANG variable /components/component/transceiver/state/post_fec_ber (container)

    YANG Description: Bit error rate after forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__post_fec_ber
      
  def _set_post_fec_ber(self, v, load=False):
    """
    Setter method for post_fec_ber, mapped from YANG variable /components/component/transceiver/state/post_fec_ber (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_post_fec_ber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_post_fec_ber() directly.

    YANG Description: Bit error rate after forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_post_fec_ber_openconfig_platform__components_component_transceiver_state_post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """post_fec_ber must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_post_fec_ber_openconfig_platform__components_component_transceiver_state_post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)""",
        })

    self.__post_fec_ber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_post_fec_ber(self):
    self.__post_fec_ber = YANGDynClass(base=yc_post_fec_ber_openconfig_platform__components_component_transceiver_state_post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)


  def _get_output_power(self):
    """
    Getter method for output_power, mapped from YANG variable /components/component/transceiver/state/output_power (container)

    YANG Description: The output optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__output_power
      
  def _set_output_power(self, v, load=False):
    """
    Setter method for output_power, mapped from YANG variable /components/component/transceiver/state/output_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_power() directly.

    YANG Description: The output optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_power_openconfig_platform__components_component_transceiver_state_output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_output_power_openconfig_platform__components_component_transceiver_state_output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)""",
        })

    self.__output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_power(self):
    self.__output_power = YANGDynClass(base=yc_output_power_openconfig_platform__components_component_transceiver_state_output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)


  def _get_input_power(self):
    """
    Getter method for input_power, mapped from YANG variable /components/component/transceiver/state/input_power (container)

    YANG Description: The input optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__input_power
      
  def _set_input_power(self, v, load=False):
    """
    Setter method for input_power, mapped from YANG variable /components/component/transceiver/state/input_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input_power() directly.

    YANG Description: The input optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_power_openconfig_platform__components_component_transceiver_state_input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_input_power_openconfig_platform__components_component_transceiver_state_input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)""",
        })

    self.__input_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input_power(self):
    self.__input_power = YANGDynClass(base=yc_input_power_openconfig_platform__components_component_transceiver_state_input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)


  def _get_laser_bias_current(self):
    """
    Getter method for laser_bias_current, mapped from YANG variable /components/component/transceiver/state/laser_bias_current (container)

    YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value
    """
    return self.__laser_bias_current
      
  def _set_laser_bias_current(self, v, load=False):
    """
    Setter method for laser_bias_current, mapped from YANG variable /components/component/transceiver/state/laser_bias_current (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_laser_bias_current is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_laser_bias_current() directly.

    YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_laser_bias_current_openconfig_platform__components_component_transceiver_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """laser_bias_current must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_laser_bias_current_openconfig_platform__components_component_transceiver_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)""",
        })

    self.__laser_bias_current = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_laser_bias_current(self):
    self.__laser_bias_current = YANGDynClass(base=yc_laser_bias_current_openconfig_platform__components_component_transceiver_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  form_factor_preconf = __builtin__.property(_get_form_factor_preconf)
  ethernet_pmd_preconf = __builtin__.property(_get_ethernet_pmd_preconf)
  fec_mode = __builtin__.property(_get_fec_mode)
  present = __builtin__.property(_get_present)
  form_factor = __builtin__.property(_get_form_factor)
  connector_type = __builtin__.property(_get_connector_type)
  vendor = __builtin__.property(_get_vendor)
  vendor_part = __builtin__.property(_get_vendor_part)
  vendor_rev = __builtin__.property(_get_vendor_rev)
  ethernet_pmd = __builtin__.property(_get_ethernet_pmd)
  sonet_sdh_compliance_code = __builtin__.property(_get_sonet_sdh_compliance_code)
  otn_compliance_code = __builtin__.property(_get_otn_compliance_code)
  serial_no = __builtin__.property(_get_serial_no)
  date_code = __builtin__.property(_get_date_code)
  fault_condition = __builtin__.property(_get_fault_condition)
  fec_status = __builtin__.property(_get_fec_status)
  fec_uncorrectable_blocks = __builtin__.property(_get_fec_uncorrectable_blocks)
  fec_uncorrectable_words = __builtin__.property(_get_fec_uncorrectable_words)
  fec_corrected_bytes = __builtin__.property(_get_fec_corrected_bytes)
  fec_corrected_bits = __builtin__.property(_get_fec_corrected_bits)
  pre_fec_ber = __builtin__.property(_get_pre_fec_ber)
  post_fec_ber = __builtin__.property(_get_post_fec_ber)
  output_power = __builtin__.property(_get_output_power)
  input_power = __builtin__.property(_get_input_power)
  laser_bias_current = __builtin__.property(_get_laser_bias_current)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('form_factor_preconf', form_factor_preconf), ('ethernet_pmd_preconf', ethernet_pmd_preconf), ('fec_mode', fec_mode), ('present', present), ('form_factor', form_factor), ('connector_type', connector_type), ('vendor', vendor), ('vendor_part', vendor_part), ('vendor_rev', vendor_rev), ('ethernet_pmd', ethernet_pmd), ('sonet_sdh_compliance_code', sonet_sdh_compliance_code), ('otn_compliance_code', otn_compliance_code), ('serial_no', serial_no), ('date_code', date_code), ('fault_condition', fault_condition), ('fec_status', fec_status), ('fec_uncorrectable_blocks', fec_uncorrectable_blocks), ('fec_uncorrectable_words', fec_uncorrectable_words), ('fec_corrected_bytes', fec_corrected_bytes), ('fec_corrected_bits', fec_corrected_bits), ('pre_fec_ber', pre_fec_ber), ('post_fec_ber', post_fec_ber), ('output_power', output_power), ('input_power', input_power), ('laser_bias_current', laser_bias_current), ])


class yc_config_openconfig_platform__components_component_transceiver_physical_channels_channel_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/transceiver/physical-channels/channel/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for physical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__description','__tx_laser','__target_output_power',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tx_laser = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tx-laser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='boolean', is_config=True)
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..max']}), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='uint16', is_config=True)
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'transceiver', u'physical-channels', u'channel', u'config']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /components/component/transceiver/physical_channels/channel/config/index (uint16)

    YANG Description: Index of the physical channnel or lane within a physical
client port
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /components/component/transceiver/physical_channels/channel/config/index (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of the physical channnel or lane within a physical
client port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..max']}), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..max']}), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='uint16', is_config=True)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..max']}), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='uint16', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /components/component/transceiver/physical_channels/channel/config/description (string)

    YANG Description: Text description for the client physical channel
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /components/component/transceiver/physical_channels/channel/config/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Text description for the client physical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=True)


  def _get_tx_laser(self):
    """
    Getter method for tx_laser, mapped from YANG variable /components/component/transceiver/physical_channels/channel/config/tx_laser (boolean)

    YANG Description: Enable (true) or disable (false) the transmit label for the
channel
    """
    return self.__tx_laser
      
  def _set_tx_laser(self, v, load=False):
    """
    Setter method for tx_laser, mapped from YANG variable /components/component/transceiver/physical_channels/channel/config/tx_laser (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_laser is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_laser() directly.

    YANG Description: Enable (true) or disable (false) the transmit label for the
channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="tx-laser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_laser must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tx-laser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='boolean', is_config=True)""",
        })

    self.__tx_laser = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_laser(self):
    self.__tx_laser = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tx-laser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='boolean', is_config=True)


  def _get_target_output_power(self):
    """
    Getter method for target_output_power, mapped from YANG variable /components/component/transceiver/physical_channels/channel/config/target_output_power (decimal64)

    YANG Description: Target output optical power level of the optical channel,
expressed in increments of 0.01 dBm (decibel-milliwats)
    """
    return self.__target_output_power
      
  def _set_target_output_power(self, v, load=False):
    """
    Setter method for target_output_power, mapped from YANG variable /components/component/transceiver/physical_channels/channel/config/target_output_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_output_power() directly.

    YANG Description: Target output optical power level of the optical channel,
expressed in increments of 0.01 dBm (decibel-milliwats)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_output_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=True)""",
        })

    self.__target_output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_output_power(self):
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=True)

  index = __builtin__.property(_get_index, _set_index)
  description = __builtin__.property(_get_description, _set_description)
  tx_laser = __builtin__.property(_get_tx_laser, _set_tx_laser)
  target_output_power = __builtin__.property(_get_target_output_power, _set_target_output_power)


  _pyangbind_elements = OrderedDict([('index', index), ('description', description), ('tx_laser', tx_laser), ('target_output_power', target_output_power), ])


class yc_output_power_openconfig_platform__components_component_transceiver_physical_channels_channel_state_output_power(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/transceiver/physical-channels/channel/state/output-power. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The output optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'output-power'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'transceiver', u'physical-channels', u'channel', u'state', u'output-power']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/output_power/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/output_power/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/output_power/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/output_power/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/output_power/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/output_power/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/output_power/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/output_power/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/output_power/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/output_power/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/output_power/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/output_power/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/output_power/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/output_power/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_input_power_openconfig_platform__components_component_transceiver_physical_channels_channel_state_input_power(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/transceiver/physical-channels/channel/state/input-power. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The input optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'input-power'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'transceiver', u'physical-channels', u'channel', u'state', u'input-power']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/input_power/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/input_power/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/input_power/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/input_power/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/input_power/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/input_power/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/input_power/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/input_power/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/input_power/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/input_power/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/input_power/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/input_power/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/input_power/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/input_power/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_laser_bias_current_openconfig_platform__components_component_transceiver_physical_channels_channel_state_laser_bias_current(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/transceiver/physical-channels/channel/state/laser-bias-current. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'laser-bias-current'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'transceiver', u'physical-channels', u'channel', u'state', u'laser-bias-current']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/laser_bias_current/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/laser_bias_current/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/laser_bias_current/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/laser_bias_current/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/laser_bias_current/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/laser_bias_current/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/laser_bias_current/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/laser_bias_current/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/laser_bias_current/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/laser_bias_current/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/laser_bias_current/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/laser_bias_current/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/laser_bias_current/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/laser_bias_current/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_state_openconfig_platform__components_component_transceiver_physical_channels_channel_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/transceiver/physical-channels/channel/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__description','__tx_laser','__target_output_power','__output_frequency','__output_power','__input_power','__laser_bias_current',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tx_laser = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tx-laser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='boolean', is_config=False)
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..max']}), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='uint16', is_config=False)
    self.__laser_bias_current = YANGDynClass(base=yc_laser_bias_current_openconfig_platform__components_component_transceiver_physical_channels_channel_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=False)
    self.__output_power = YANGDynClass(base=yc_output_power_openconfig_platform__components_component_transceiver_physical_channels_channel_state_output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    self.__output_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="output-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-opt-types:frequency-type', is_config=False)
    self.__input_power = YANGDynClass(base=yc_input_power_openconfig_platform__components_component_transceiver_physical_channels_channel_state_input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'transceiver', u'physical-channels', u'channel', u'state']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/index (uint16)

    YANG Description: Index of the physical channnel or lane within a physical
client port
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/index (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of the physical channnel or lane within a physical
client port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..max']}), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..max']}), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='uint16', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={u'range': [u'0..max']}), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='uint16', is_config=False)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/description (string)

    YANG Description: Text description for the client physical channel
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Text description for the client physical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=False)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='string', is_config=False)


  def _get_tx_laser(self):
    """
    Getter method for tx_laser, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/tx_laser (boolean)

    YANG Description: Enable (true) or disable (false) the transmit label for the
channel
    """
    return self.__tx_laser
      
  def _set_tx_laser(self, v, load=False):
    """
    Setter method for tx_laser, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/tx_laser (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_laser is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_laser() directly.

    YANG Description: Enable (true) or disable (false) the transmit label for the
channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="tx-laser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_laser must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tx-laser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='boolean', is_config=False)""",
        })

    self.__tx_laser = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_laser(self):
    self.__tx_laser = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tx-laser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='boolean', is_config=False)


  def _get_target_output_power(self):
    """
    Getter method for target_output_power, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/target_output_power (decimal64)

    YANG Description: Target output optical power level of the optical channel,
expressed in increments of 0.01 dBm (decibel-milliwats)
    """
    return self.__target_output_power
      
  def _set_target_output_power(self, v, load=False):
    """
    Setter method for target_output_power, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/target_output_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_output_power() directly.

    YANG Description: Target output optical power level of the optical channel,
expressed in increments of 0.01 dBm (decibel-milliwats)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_output_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)""",
        })

    self.__target_output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_output_power(self):
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='decimal64', is_config=False)


  def _get_output_frequency(self):
    """
    Getter method for output_frequency, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/output_frequency (oc-opt-types:frequency-type)

    YANG Description: The frequency in MHz of the individual physical channel
(e.g. ITU C50 - 195.0THz and would be reported as
195,000,000 MHz in this model). This attribute is not
configurable on most client ports.
    """
    return self.__output_frequency
      
  def _set_output_frequency(self, v, load=False):
    """
    Setter method for output_frequency, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/output_frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_frequency() directly.

    YANG Description: The frequency in MHz of the individual physical channel
(e.g. ITU C50 - 195.0THz and would be reported as
195,000,000 MHz in this model). This attribute is not
configurable on most client ports.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="output-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-opt-types:frequency-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="output-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-opt-types:frequency-type', is_config=False)""",
        })

    self.__output_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_frequency(self):
    self.__output_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="output-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='oc-opt-types:frequency-type', is_config=False)


  def _get_output_power(self):
    """
    Getter method for output_power, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/output_power (container)

    YANG Description: The output optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__output_power
      
  def _set_output_power(self, v, load=False):
    """
    Setter method for output_power, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/output_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_power() directly.

    YANG Description: The output optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_power_openconfig_platform__components_component_transceiver_physical_channels_channel_state_output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_output_power_openconfig_platform__components_component_transceiver_physical_channels_channel_state_output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)""",
        })

    self.__output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_power(self):
    self.__output_power = YANGDynClass(base=yc_output_power_openconfig_platform__components_component_transceiver_physical_channels_channel_state_output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)


  def _get_input_power(self):
    """
    Getter method for input_power, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/input_power (container)

    YANG Description: The input optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__input_power
      
  def _set_input_power(self, v, load=False):
    """
    Setter method for input_power, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/input_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input_power() directly.

    YANG Description: The input optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_power_openconfig_platform__components_component_transceiver_physical_channels_channel_state_input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_input_power_openconfig_platform__components_component_transceiver_physical_channels_channel_state_input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)""",
        })

    self.__input_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input_power(self):
    self.__input_power = YANGDynClass(base=yc_input_power_openconfig_platform__components_component_transceiver_physical_channels_channel_state_input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)


  def _get_laser_bias_current(self):
    """
    Getter method for laser_bias_current, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/laser_bias_current (container)

    YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value
    """
    return self.__laser_bias_current
      
  def _set_laser_bias_current(self, v, load=False):
    """
    Setter method for laser_bias_current, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/laser_bias_current (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_laser_bias_current is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_laser_bias_current() directly.

    YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_laser_bias_current_openconfig_platform__components_component_transceiver_physical_channels_channel_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """laser_bias_current must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_laser_bias_current_openconfig_platform__components_component_transceiver_physical_channels_channel_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)""",
        })

    self.__laser_bias_current = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_laser_bias_current(self):
    self.__laser_bias_current = YANGDynClass(base=yc_laser_bias_current_openconfig_platform__components_component_transceiver_physical_channels_channel_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=False)

  index = __builtin__.property(_get_index)
  description = __builtin__.property(_get_description)
  tx_laser = __builtin__.property(_get_tx_laser)
  target_output_power = __builtin__.property(_get_target_output_power)
  output_frequency = __builtin__.property(_get_output_frequency)
  output_power = __builtin__.property(_get_output_power)
  input_power = __builtin__.property(_get_input_power)
  laser_bias_current = __builtin__.property(_get_laser_bias_current)


  _pyangbind_elements = OrderedDict([('index', index), ('description', description), ('tx_laser', tx_laser), ('target_output_power', target_output_power), ('output_frequency', output_frequency), ('output_power', output_power), ('input_power', input_power), ('laser_bias_current', laser_bias_current), ])


class yc_channel_openconfig_platform__components_component_transceiver_physical_channels_channel(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/transceiver/physical-channels/channel. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of client channels, keyed by index within a physical
client port.  A physical port with a single channel would
have a single zero-indexed element
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__config','__state',)

  _yang_name = 'channel'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='leafref', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_platform__components_component_transceiver_physical_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_platform__components_component_transceiver_physical_channels_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'transceiver', u'physical-channels', u'channel']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /components/component/transceiver/physical_channels/channel/index (leafref)

    YANG Description: Reference to the index number of the channel
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /components/component/transceiver/physical_channels/channel/index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Reference to the index number of the channel
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='leafref', is_config=True)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /components/component/transceiver/physical_channels/channel/config (container)

    YANG Description: Configuration data for physical channels
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /components/component/transceiver/physical_channels/channel/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for physical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_platform__components_component_transceiver_physical_channels_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_platform__components_component_transceiver_physical_channels_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_platform__components_component_transceiver_physical_channels_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state (container)

    YANG Description: Operational state data for channels
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_platform__components_component_transceiver_physical_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_platform__components_component_transceiver_physical_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_platform__components_component_transceiver_physical_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)

  index = __builtin__.property(_get_index, _set_index)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('index', index), ('config', config), ('state', state), ])


class yc_physical_channels_openconfig_platform__components_component_transceiver_physical_channels(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/transceiver/physical-channels. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for client channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__channel',)

  _yang_name = 'physical-channels'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__channel = YANGDynClass(base=YANGListType("index",yc_channel_openconfig_platform__components_component_transceiver_physical_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'transceiver', u'physical-channels']

  def _get_channel(self):
    """
    Getter method for channel, mapped from YANG variable /components/component/transceiver/physical_channels/channel (list)

    YANG Description: List of client channels, keyed by index within a physical
client port.  A physical port with a single channel would
have a single zero-indexed element
    """
    return self.__channel
      
  def _set_channel(self, v, load=False):
    """
    Setter method for channel, mapped from YANG variable /components/component/transceiver/physical_channels/channel (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel() directly.

    YANG Description: List of client channels, keyed by index within a physical
client port.  A physical port with a single channel would
have a single zero-indexed element
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("index",yc_channel_openconfig_platform__components_component_transceiver_physical_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("index",yc_channel_openconfig_platform__components_component_transceiver_physical_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='list', is_config=True)""",
        })

    self.__channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel(self):
    self.__channel = YANGDynClass(base=YANGListType("index",yc_channel_openconfig_platform__components_component_transceiver_physical_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='list', is_config=True)

  channel = __builtin__.property(_get_channel, _set_channel)


  _pyangbind_elements = OrderedDict([('channel', channel), ])


class yc_transceiver_openconfig_platform__components_component_transceiver(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/transceiver. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for client port transceiver data
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__physical_channels',)

  _yang_name = 'transceiver'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_platform__components_component_transceiver_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)
    self.__physical_channels = YANGDynClass(base=yc_physical_channels_openconfig_platform__components_component_transceiver_physical_channels, is_container='container', yang_name="physical-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_platform__components_component_transceiver_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'transceiver']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /components/component/transceiver/config (container)

    YANG Description: Configuration data for client port transceivers
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /components/component/transceiver/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for client port transceivers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_platform__components_component_transceiver_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_platform__components_component_transceiver_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_platform__components_component_transceiver_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /components/component/transceiver/state (container)

    YANG Description: Operational state data for client port transceivers
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /components/component/transceiver/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for client port transceivers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_platform__components_component_transceiver_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_platform__components_component_transceiver_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_platform__components_component_transceiver_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)


  def _get_physical_channels(self):
    """
    Getter method for physical_channels, mapped from YANG variable /components/component/transceiver/physical_channels (container)

    YANG Description: Enclosing container for client channels
    """
    return self.__physical_channels
      
  def _set_physical_channels(self, v, load=False):
    """
    Setter method for physical_channels, mapped from YANG variable /components/component/transceiver/physical_channels (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physical_channels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physical_channels() directly.

    YANG Description: Enclosing container for client channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_physical_channels_openconfig_platform__components_component_transceiver_physical_channels, is_container='container', yang_name="physical-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """physical_channels must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_physical_channels_openconfig_platform__components_component_transceiver_physical_channels, is_container='container', yang_name="physical-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)""",
        })

    self.__physical_channels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_physical_channels(self):
    self.__physical_channels = YANGDynClass(base=yc_physical_channels_openconfig_platform__components_component_transceiver_physical_channels, is_container='container', yang_name="physical-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  physical_channels = __builtin__.property(_get_physical_channels, _set_physical_channels)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('physical_channels', physical_channels), ])


class yc_config_openconfig_platform__components_component_optical_channel_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/optical-channel/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for optical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__frequency','__target_output_power','__operational_mode','__line_port',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__line_port = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    self.__operational_mode = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=True)
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=True)
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'optical-channel', u'config']

  def _get_frequency(self):
    """
    Getter method for frequency, mapped from YANG variable /components/component/optical_channel/config/frequency (oc-opt-types:frequency-type)

    YANG Description: Frequency of the optical channel, expressed in MHz
    """
    return self.__frequency
      
  def _set_frequency(self, v, load=False):
    """
    Setter method for frequency, mapped from YANG variable /components/component/optical_channel/config/frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frequency() directly.

    YANG Description: Frequency of the optical channel, expressed in MHz
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=True)""",
        })

    self.__frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frequency(self):
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=True)


  def _get_target_output_power(self):
    """
    Getter method for target_output_power, mapped from YANG variable /components/component/optical_channel/config/target_output_power (decimal64)

    YANG Description: Target output optical power level of the optical channel,
expressed in increments of 0.01 dBm (decibel-milliwats)
    """
    return self.__target_output_power
      
  def _set_target_output_power(self, v, load=False):
    """
    Setter method for target_output_power, mapped from YANG variable /components/component/optical_channel/config/target_output_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_output_power() directly.

    YANG Description: Target output optical power level of the optical channel,
expressed in increments of 0.01 dBm (decibel-milliwats)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_output_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=True)""",
        })

    self.__target_output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_output_power(self):
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=True)


  def _get_operational_mode(self):
    """
    Getter method for operational_mode, mapped from YANG variable /components/component/optical_channel/config/operational_mode (uint16)

    YANG Description: Vendor-specific mode identifier -- sets the operational
mode for the channel.  The specified operational mode must
exist in the list of supported operational modes supplied
by the device
    """
    return self.__operational_mode
      
  def _set_operational_mode(self, v, load=False):
    """
    Setter method for operational_mode, mapped from YANG variable /components/component/optical_channel/config/operational_mode (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operational_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operational_mode() directly.

    YANG Description: Vendor-specific mode identifier -- sets the operational
mode for the channel.  The specified operational mode must
exist in the list of supported operational modes supplied
by the device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operational_mode must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=True)""",
        })

    self.__operational_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operational_mode(self):
    self.__operational_mode = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=True)


  def _get_line_port(self):
    """
    Getter method for line_port, mapped from YANG variable /components/component/optical_channel/config/line_port (leafref)

    YANG Description: Reference to the line-side physical port that carries
this optical channel.  The target port should be
a component in the physical inventory data model.
    """
    return self.__line_port
      
  def _set_line_port(self, v, load=False):
    """
    Setter method for line_port, mapped from YANG variable /components/component/optical_channel/config/line_port (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_line_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_line_port() directly.

    YANG Description: Reference to the line-side physical port that carries
this optical channel.  The target port should be
a component in the physical inventory data model.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """line_port must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)""",
        })

    self.__line_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_line_port(self):
    self.__line_port = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)

  frequency = __builtin__.property(_get_frequency, _set_frequency)
  target_output_power = __builtin__.property(_get_target_output_power, _set_target_output_power)
  operational_mode = __builtin__.property(_get_operational_mode, _set_operational_mode)
  line_port = __builtin__.property(_get_line_port, _set_line_port)


  _pyangbind_elements = OrderedDict([('frequency', frequency), ('target_output_power', target_output_power), ('operational_mode', operational_mode), ('line_port', line_port), ])


class yc_output_power_openconfig_platform__components_component_optical_channel_state_output_power(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/optical-channel/state/output-power. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The output optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'output-power'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'optical-channel', u'state', u'output-power']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /components/component/optical_channel/state/output_power/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /components/component/optical_channel/state/output_power/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /components/component/optical_channel/state/output_power/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /components/component/optical_channel/state/output_power/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /components/component/optical_channel/state/output_power/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /components/component/optical_channel/state/output_power/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /components/component/optical_channel/state/output_power/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /components/component/optical_channel/state/output_power/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /components/component/optical_channel/state/output_power/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /components/component/optical_channel/state/output_power/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /components/component/optical_channel/state/output_power/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /components/component/optical_channel/state/output_power/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /components/component/optical_channel/state/output_power/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /components/component/optical_channel/state/output_power/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_input_power_openconfig_platform__components_component_optical_channel_state_input_power(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/optical-channel/state/input-power. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The input optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'input-power'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'optical-channel', u'state', u'input-power']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /components/component/optical_channel/state/input_power/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /components/component/optical_channel/state/input_power/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /components/component/optical_channel/state/input_power/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /components/component/optical_channel/state/input_power/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /components/component/optical_channel/state/input_power/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /components/component/optical_channel/state/input_power/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /components/component/optical_channel/state/input_power/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /components/component/optical_channel/state/input_power/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /components/component/optical_channel/state/input_power/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /components/component/optical_channel/state/input_power/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /components/component/optical_channel/state/input_power/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /components/component/optical_channel/state/input_power/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /components/component/optical_channel/state/input_power/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /components/component/optical_channel/state/input_power/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_laser_bias_current_openconfig_platform__components_component_optical_channel_state_laser_bias_current(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/optical-channel/state/laser-bias-current. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'laser-bias-current'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'optical-channel', u'state', u'laser-bias-current']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_chromatic_dispersion_openconfig_platform__components_component_optical_channel_state_chromatic_dispersion(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/optical-channel/state/chromatic-dispersion. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Chromatic Dispersion of an optical channel in
picoseconds / nanometer (ps/nm) as reported by receiver
with two decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected to just
supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'chromatic-dispersion'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'optical-channel', u'state', u'chromatic-dispersion']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion/min (decimal64)

    YANG Description: The minimum value of the statistic over the time interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_polarization_mode_dispersion_openconfig_platform__components_component_optical_channel_state_polarization_mode_dispersion(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/optical-channel/state/polarization-mode-dispersion. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Polarization Mode Dispersion of an optical channel
in picosends (ps) as reported by receiver with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply the
instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'polarization-mode-dispersion'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'optical-channel', u'state', u'polarization-mode-dispersion']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion/min (decimal64)

    YANG Description: The minimum value of the statistic over the time interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion/max (decimal64)

    YANG Description: The maximum value of the statistic over the time interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_second_order_polarization_mode_dispersion_openconfig_platform__components_component_optical_channel_state_second_order_polarization_mode_dispersion(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/optical-channel/state/second-order-polarization-mode-dispersion. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Second Order Polarization Mode Dispersion of an optical
channel in picoseconds squared (ps^2) as reported by
receiver with two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target
is expected to just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'second-order-polarization-mode-dispersion'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'optical-channel', u'state', u'second-order-polarization-mode-dispersion']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion/min (decimal64)

    YANG Description: The minimum value of the statistic over the time interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_polarization_dependent_loss_openconfig_platform__components_component_optical_channel_state_polarization_dependent_loss(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/optical-channel/state/polarization-dependent-loss. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Polarization Dependent Loss of an optical channel
in dB as reported by receiver with two decimal precision.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'polarization-dependent-loss'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'optical-channel', u'state', u'polarization-dependent-loss']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss/min (decimal64)

    YANG Description: The minimum value of the statistic over the time interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_state_openconfig_platform__components_component_optical_channel_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/optical-channel/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for optical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__frequency','__target_output_power','__operational_mode','__line_port','__group_id','__output_power','__input_power','__laser_bias_current','__chromatic_dispersion','__polarization_mode_dispersion','__second_order_polarization_mode_dispersion','__polarization_dependent_loss',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__output_power = YANGDynClass(base=yc_output_power_openconfig_platform__components_component_optical_channel_state_output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__operational_mode = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)
    self.__laser_bias_current = YANGDynClass(base=yc_laser_bias_current_openconfig_platform__components_component_optical_channel_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__line_port = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__second_order_polarization_mode_dispersion = YANGDynClass(base=yc_second_order_polarization_mode_dispersion_openconfig_platform__components_component_optical_channel_state_second_order_polarization_mode_dispersion, is_container='container', yang_name="second-order-polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=False)
    self.__polarization_mode_dispersion = YANGDynClass(base=yc_polarization_mode_dispersion_openconfig_platform__components_component_optical_channel_state_polarization_mode_dispersion, is_container='container', yang_name="polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__polarization_dependent_loss = YANGDynClass(base=yc_polarization_dependent_loss_openconfig_platform__components_component_optical_channel_state_polarization_dependent_loss, is_container='container', yang_name="polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__group_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    self.__input_power = YANGDynClass(base=yc_input_power_openconfig_platform__components_component_optical_channel_state_input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__chromatic_dispersion = YANGDynClass(base=yc_chromatic_dispersion_openconfig_platform__components_component_optical_channel_state_chromatic_dispersion, is_container='container', yang_name="chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'optical-channel', u'state']

  def _get_frequency(self):
    """
    Getter method for frequency, mapped from YANG variable /components/component/optical_channel/state/frequency (oc-opt-types:frequency-type)

    YANG Description: Frequency of the optical channel, expressed in MHz
    """
    return self.__frequency
      
  def _set_frequency(self, v, load=False):
    """
    Setter method for frequency, mapped from YANG variable /components/component/optical_channel/state/frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frequency() directly.

    YANG Description: Frequency of the optical channel, expressed in MHz
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=False)""",
        })

    self.__frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frequency(self):
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=False)


  def _get_target_output_power(self):
    """
    Getter method for target_output_power, mapped from YANG variable /components/component/optical_channel/state/target_output_power (decimal64)

    YANG Description: Target output optical power level of the optical channel,
expressed in increments of 0.01 dBm (decibel-milliwats)
    """
    return self.__target_output_power
      
  def _set_target_output_power(self, v, load=False):
    """
    Setter method for target_output_power, mapped from YANG variable /components/component/optical_channel/state/target_output_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_output_power() directly.

    YANG Description: Target output optical power level of the optical channel,
expressed in increments of 0.01 dBm (decibel-milliwats)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_output_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__target_output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_output_power(self):
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_operational_mode(self):
    """
    Getter method for operational_mode, mapped from YANG variable /components/component/optical_channel/state/operational_mode (uint16)

    YANG Description: Vendor-specific mode identifier -- sets the operational
mode for the channel.  The specified operational mode must
exist in the list of supported operational modes supplied
by the device
    """
    return self.__operational_mode
      
  def _set_operational_mode(self, v, load=False):
    """
    Setter method for operational_mode, mapped from YANG variable /components/component/optical_channel/state/operational_mode (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operational_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operational_mode() directly.

    YANG Description: Vendor-specific mode identifier -- sets the operational
mode for the channel.  The specified operational mode must
exist in the list of supported operational modes supplied
by the device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operational_mode must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)""",
        })

    self.__operational_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operational_mode(self):
    self.__operational_mode = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)


  def _get_line_port(self):
    """
    Getter method for line_port, mapped from YANG variable /components/component/optical_channel/state/line_port (leafref)

    YANG Description: Reference to the line-side physical port that carries
this optical channel.  The target port should be
a component in the physical inventory data model.
    """
    return self.__line_port
      
  def _set_line_port(self, v, load=False):
    """
    Setter method for line_port, mapped from YANG variable /components/component/optical_channel/state/line_port (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_line_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_line_port() directly.

    YANG Description: Reference to the line-side physical port that carries
this optical channel.  The target port should be
a component in the physical inventory data model.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """line_port must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__line_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_line_port(self):
    self.__line_port = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_group_id(self):
    """
    Getter method for group_id, mapped from YANG variable /components/component/optical_channel/state/group_id (uint32)

    YANG Description: If the device places constraints on which optical
channels must be managed together (e.g., transmitted on the
same line port), it can indicate that by setting the group-id
to the same value across related optical channels.
    """
    return self.__group_id
      
  def _set_group_id(self, v, load=False):
    """
    Setter method for group_id, mapped from YANG variable /components/component/optical_channel/state/group_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group_id() directly.

    YANG Description: If the device places constraints on which optical
channels must be managed together (e.g., transmitted on the
same line port), it can indicate that by setting the group-id
to the same value across related optical channels.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)""",
        })

    self.__group_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group_id(self):
    self.__group_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)


  def _get_output_power(self):
    """
    Getter method for output_power, mapped from YANG variable /components/component/optical_channel/state/output_power (container)

    YANG Description: The output optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__output_power
      
  def _set_output_power(self, v, load=False):
    """
    Setter method for output_power, mapped from YANG variable /components/component/optical_channel/state/output_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_power() directly.

    YANG Description: The output optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_power_openconfig_platform__components_component_optical_channel_state_output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_output_power_openconfig_platform__components_component_optical_channel_state_output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_power(self):
    self.__output_power = YANGDynClass(base=yc_output_power_openconfig_platform__components_component_optical_channel_state_output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_input_power(self):
    """
    Getter method for input_power, mapped from YANG variable /components/component/optical_channel/state/input_power (container)

    YANG Description: The input optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__input_power
      
  def _set_input_power(self, v, load=False):
    """
    Setter method for input_power, mapped from YANG variable /components/component/optical_channel/state/input_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input_power() directly.

    YANG Description: The input optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_power_openconfig_platform__components_component_optical_channel_state_input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_input_power_openconfig_platform__components_component_optical_channel_state_input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__input_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input_power(self):
    self.__input_power = YANGDynClass(base=yc_input_power_openconfig_platform__components_component_optical_channel_state_input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_laser_bias_current(self):
    """
    Getter method for laser_bias_current, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current (container)

    YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value
    """
    return self.__laser_bias_current
      
  def _set_laser_bias_current(self, v, load=False):
    """
    Setter method for laser_bias_current, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_laser_bias_current is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_laser_bias_current() directly.

    YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_laser_bias_current_openconfig_platform__components_component_optical_channel_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """laser_bias_current must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_laser_bias_current_openconfig_platform__components_component_optical_channel_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__laser_bias_current = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_laser_bias_current(self):
    self.__laser_bias_current = YANGDynClass(base=yc_laser_bias_current_openconfig_platform__components_component_optical_channel_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_chromatic_dispersion(self):
    """
    Getter method for chromatic_dispersion, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion (container)

    YANG Description: Chromatic Dispersion of an optical channel in
picoseconds / nanometer (ps/nm) as reported by receiver
with two decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected to just
supply the instant value
    """
    return self.__chromatic_dispersion
      
  def _set_chromatic_dispersion(self, v, load=False):
    """
    Setter method for chromatic_dispersion, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_chromatic_dispersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_chromatic_dispersion() directly.

    YANG Description: Chromatic Dispersion of an optical channel in
picoseconds / nanometer (ps/nm) as reported by receiver
with two decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected to just
supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_chromatic_dispersion_openconfig_platform__components_component_optical_channel_state_chromatic_dispersion, is_container='container', yang_name="chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """chromatic_dispersion must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_chromatic_dispersion_openconfig_platform__components_component_optical_channel_state_chromatic_dispersion, is_container='container', yang_name="chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__chromatic_dispersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_chromatic_dispersion(self):
    self.__chromatic_dispersion = YANGDynClass(base=yc_chromatic_dispersion_openconfig_platform__components_component_optical_channel_state_chromatic_dispersion, is_container='container', yang_name="chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_polarization_mode_dispersion(self):
    """
    Getter method for polarization_mode_dispersion, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion (container)

    YANG Description: Polarization Mode Dispersion of an optical channel
in picosends (ps) as reported by receiver with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply the
instant value
    """
    return self.__polarization_mode_dispersion
      
  def _set_polarization_mode_dispersion(self, v, load=False):
    """
    Setter method for polarization_mode_dispersion, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_polarization_mode_dispersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_polarization_mode_dispersion() directly.

    YANG Description: Polarization Mode Dispersion of an optical channel
in picosends (ps) as reported by receiver with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_polarization_mode_dispersion_openconfig_platform__components_component_optical_channel_state_polarization_mode_dispersion, is_container='container', yang_name="polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """polarization_mode_dispersion must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_polarization_mode_dispersion_openconfig_platform__components_component_optical_channel_state_polarization_mode_dispersion, is_container='container', yang_name="polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__polarization_mode_dispersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_polarization_mode_dispersion(self):
    self.__polarization_mode_dispersion = YANGDynClass(base=yc_polarization_mode_dispersion_openconfig_platform__components_component_optical_channel_state_polarization_mode_dispersion, is_container='container', yang_name="polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_second_order_polarization_mode_dispersion(self):
    """
    Getter method for second_order_polarization_mode_dispersion, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion (container)

    YANG Description: Second Order Polarization Mode Dispersion of an optical
channel in picoseconds squared (ps^2) as reported by
receiver with two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target
is expected to just supply the instant value
    """
    return self.__second_order_polarization_mode_dispersion
      
  def _set_second_order_polarization_mode_dispersion(self, v, load=False):
    """
    Setter method for second_order_polarization_mode_dispersion, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_second_order_polarization_mode_dispersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_second_order_polarization_mode_dispersion() directly.

    YANG Description: Second Order Polarization Mode Dispersion of an optical
channel in picoseconds squared (ps^2) as reported by
receiver with two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target
is expected to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_second_order_polarization_mode_dispersion_openconfig_platform__components_component_optical_channel_state_second_order_polarization_mode_dispersion, is_container='container', yang_name="second-order-polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """second_order_polarization_mode_dispersion must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_second_order_polarization_mode_dispersion_openconfig_platform__components_component_optical_channel_state_second_order_polarization_mode_dispersion, is_container='container', yang_name="second-order-polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__second_order_polarization_mode_dispersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_second_order_polarization_mode_dispersion(self):
    self.__second_order_polarization_mode_dispersion = YANGDynClass(base=yc_second_order_polarization_mode_dispersion_openconfig_platform__components_component_optical_channel_state_second_order_polarization_mode_dispersion, is_container='container', yang_name="second-order-polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_polarization_dependent_loss(self):
    """
    Getter method for polarization_dependent_loss, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss (container)

    YANG Description: Polarization Dependent Loss of an optical channel
in dB as reported by receiver with two decimal precision.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__polarization_dependent_loss
      
  def _set_polarization_dependent_loss(self, v, load=False):
    """
    Setter method for polarization_dependent_loss, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_polarization_dependent_loss is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_polarization_dependent_loss() directly.

    YANG Description: Polarization Dependent Loss of an optical channel
in dB as reported by receiver with two decimal precision.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_polarization_dependent_loss_openconfig_platform__components_component_optical_channel_state_polarization_dependent_loss, is_container='container', yang_name="polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """polarization_dependent_loss must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_polarization_dependent_loss_openconfig_platform__components_component_optical_channel_state_polarization_dependent_loss, is_container='container', yang_name="polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__polarization_dependent_loss = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_polarization_dependent_loss(self):
    self.__polarization_dependent_loss = YANGDynClass(base=yc_polarization_dependent_loss_openconfig_platform__components_component_optical_channel_state_polarization_dependent_loss, is_container='container', yang_name="polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

  frequency = __builtin__.property(_get_frequency)
  target_output_power = __builtin__.property(_get_target_output_power)
  operational_mode = __builtin__.property(_get_operational_mode)
  line_port = __builtin__.property(_get_line_port)
  group_id = __builtin__.property(_get_group_id)
  output_power = __builtin__.property(_get_output_power)
  input_power = __builtin__.property(_get_input_power)
  laser_bias_current = __builtin__.property(_get_laser_bias_current)
  chromatic_dispersion = __builtin__.property(_get_chromatic_dispersion)
  polarization_mode_dispersion = __builtin__.property(_get_polarization_mode_dispersion)
  second_order_polarization_mode_dispersion = __builtin__.property(_get_second_order_polarization_mode_dispersion)
  polarization_dependent_loss = __builtin__.property(_get_polarization_dependent_loss)


  _pyangbind_elements = OrderedDict([('frequency', frequency), ('target_output_power', target_output_power), ('operational_mode', operational_mode), ('line_port', line_port), ('group_id', group_id), ('output_power', output_power), ('input_power', input_power), ('laser_bias_current', laser_bias_current), ('chromatic_dispersion', chromatic_dispersion), ('polarization_mode_dispersion', polarization_mode_dispersion), ('second_order_polarization_mode_dispersion', second_order_polarization_mode_dispersion), ('polarization_dependent_loss', polarization_dependent_loss), ])


class yc_optical_channel_openconfig_platform__components_component_optical_channel(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/optical-channel. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for the list of optical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'optical-channel'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_platform__components_component_optical_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_platform__components_component_optical_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'optical-channel']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /components/component/optical_channel/config (container)

    YANG Description: Configuration data for optical channels
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /components/component/optical_channel/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for optical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_platform__components_component_optical_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_platform__components_component_optical_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_platform__components_component_optical_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /components/component/optical_channel/state (container)

    YANG Description: Operational state data for optical channels
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /components/component/optical_channel/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for optical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_platform__components_component_optical_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_platform__components_component_optical_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_platform__components_component_optical_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_platform__components_component_linecard_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/linecard/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for linecards
  """
  __slots__ = ('_path_helper', '_extmethods', '__power_admin_state',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__power_admin_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'POWER_ENABLED': {}, u'POWER_DISABLED': {}},), default=six.text_type("POWER_ENABLED"), is_leaf=True, yang_name="power-admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='oc-platform-types:component-power-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'linecard', u'config']

  def _get_power_admin_state(self):
    """
    Getter method for power_admin_state, mapped from YANG variable /components/component/linecard/config/power_admin_state (oc-platform-types:component-power-type)

    YANG Description: Enable or disable power to the linecard
    """
    return self.__power_admin_state
      
  def _set_power_admin_state(self, v, load=False):
    """
    Setter method for power_admin_state, mapped from YANG variable /components/component/linecard/config/power_admin_state (oc-platform-types:component-power-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_power_admin_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_power_admin_state() directly.

    YANG Description: Enable or disable power to the linecard
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'POWER_ENABLED': {}, u'POWER_DISABLED': {}},), default=six.text_type("POWER_ENABLED"), is_leaf=True, yang_name="power-admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='oc-platform-types:component-power-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """power_admin_state must be of a type compatible with oc-platform-types:component-power-type""",
          'defined-type': "oc-platform-types:component-power-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'POWER_ENABLED': {}, u'POWER_DISABLED': {}},), default=six.text_type("POWER_ENABLED"), is_leaf=True, yang_name="power-admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='oc-platform-types:component-power-type', is_config=True)""",
        })

    self.__power_admin_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_power_admin_state(self):
    self.__power_admin_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'POWER_ENABLED': {}, u'POWER_DISABLED': {}},), default=six.text_type("POWER_ENABLED"), is_leaf=True, yang_name="power-admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='oc-platform-types:component-power-type', is_config=True)

  power_admin_state = __builtin__.property(_get_power_admin_state, _set_power_admin_state)


  _pyangbind_elements = OrderedDict([('power_admin_state', power_admin_state), ])


class yc_state_openconfig_platform__components_component_linecard_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/linecard/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for linecards
  """
  __slots__ = ('_path_helper', '_extmethods', '__power_admin_state','__slot_id',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__slot_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='string', is_config=False)
    self.__power_admin_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'POWER_ENABLED': {}, u'POWER_DISABLED': {}},), default=six.text_type("POWER_ENABLED"), is_leaf=True, yang_name="power-admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='oc-platform-types:component-power-type', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'linecard', u'state']

  def _get_power_admin_state(self):
    """
    Getter method for power_admin_state, mapped from YANG variable /components/component/linecard/state/power_admin_state (oc-platform-types:component-power-type)

    YANG Description: Enable or disable power to the linecard
    """
    return self.__power_admin_state
      
  def _set_power_admin_state(self, v, load=False):
    """
    Setter method for power_admin_state, mapped from YANG variable /components/component/linecard/state/power_admin_state (oc-platform-types:component-power-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_power_admin_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_power_admin_state() directly.

    YANG Description: Enable or disable power to the linecard
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'POWER_ENABLED': {}, u'POWER_DISABLED': {}},), default=six.text_type("POWER_ENABLED"), is_leaf=True, yang_name="power-admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='oc-platform-types:component-power-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """power_admin_state must be of a type compatible with oc-platform-types:component-power-type""",
          'defined-type': "oc-platform-types:component-power-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'POWER_ENABLED': {}, u'POWER_DISABLED': {}},), default=six.text_type("POWER_ENABLED"), is_leaf=True, yang_name="power-admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='oc-platform-types:component-power-type', is_config=False)""",
        })

    self.__power_admin_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_power_admin_state(self):
    self.__power_admin_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'POWER_ENABLED': {}, u'POWER_DISABLED': {}},), default=six.text_type("POWER_ENABLED"), is_leaf=True, yang_name="power-admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='oc-platform-types:component-power-type', is_config=False)


  def _get_slot_id(self):
    """
    Getter method for slot_id, mapped from YANG variable /components/component/linecard/state/slot_id (string)

    YANG Description: Identifier for the slot or chassis position in which the
linecard is installed
    """
    return self.__slot_id
      
  def _set_slot_id(self, v, load=False):
    """
    Setter method for slot_id, mapped from YANG variable /components/component/linecard/state/slot_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slot_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slot_id() directly.

    YANG Description: Identifier for the slot or chassis position in which the
linecard is installed
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="slot-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slot_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='string', is_config=False)""",
        })

    self.__slot_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slot_id(self):
    self.__slot_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='string', is_config=False)

  power_admin_state = __builtin__.property(_get_power_admin_state)
  slot_id = __builtin__.property(_get_slot_id)


  _pyangbind_elements = OrderedDict([('power_admin_state', power_admin_state), ('slot_id', slot_id), ])


class yc_linecard_openconfig_platform__components_component_linecard(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/linecard. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for linecard data
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'linecard'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_platform__components_component_linecard_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_platform__components_component_linecard_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component', u'linecard']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /components/component/linecard/config (container)

    YANG Description: Configuration data for linecards
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /components/component/linecard/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for linecards
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_platform__components_component_linecard_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_platform__components_component_linecard_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_platform__components_component_linecard_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /components/component/linecard/state (container)

    YANG Description: Operational state data for linecards
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /components/component/linecard/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for linecards
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_platform__components_component_linecard_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_platform__components_component_linecard_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_platform__components_component_linecard_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_component_openconfig_platform__components_component(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of components, keyed by component name.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__config','__state','__properties','__subcomponents','__chassis','__port','__power_supply','__fan','__fabric','__storage','__cpu','__integrated_circuit','__backplane','__transceiver','__optical_channel','__linecard',)

  _yang_name = 'component'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)
    self.__linecard = YANGDynClass(base=yc_linecard_openconfig_platform__components_component_linecard, is_container='container', yang_name="linecard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='container', is_config=True)
    self.__cpu = YANGDynClass(base=yc_cpu_openconfig_platform__components_component_cpu, is_container='container', yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__storage = YANGDynClass(base=yc_storage_openconfig_platform__components_component_storage, is_container='container', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__subcomponents = YANGDynClass(base=yc_subcomponents_openconfig_platform__components_component_subcomponents, is_container='container', yang_name="subcomponents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__port = YANGDynClass(base=yc_port_openconfig_platform__components_component_port, is_container='container', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__transceiver = YANGDynClass(base=yc_transceiver_openconfig_platform__components_component_transceiver, is_container='container', yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_platform__components_component_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__chassis = YANGDynClass(base=yc_chassis_openconfig_platform__components_component_chassis, is_container='container', yang_name="chassis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__fan = YANGDynClass(base=yc_fan_openconfig_platform__components_component_fan, is_container='container', yang_name="fan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__fabric = YANGDynClass(base=yc_fabric_openconfig_platform__components_component_fabric, is_container='container', yang_name="fabric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__backplane = YANGDynClass(base=yc_backplane_openconfig_platform__components_component_backplane, is_container='container', yang_name="backplane", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__integrated_circuit = YANGDynClass(base=yc_integrated_circuit_openconfig_platform__components_component_integrated_circuit, is_container='container', yang_name="integrated-circuit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__optical_channel = YANGDynClass(base=yc_optical_channel_openconfig_platform__components_component_optical_channel, is_container='container', yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_platform__components_component_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__properties = YANGDynClass(base=yc_properties_openconfig_platform__components_component_properties, is_container='container', yang_name="properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__power_supply = YANGDynClass(base=yc_power_supply_openconfig_platform__components_component_power_supply, is_container='container', yang_name="power-supply", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components', u'component']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/name (leafref)

    YANG Description: References the component name
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: References the component name
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /components/component/config (container)

    YANG Description: Configuration data for each component
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /components/component/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for each component
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_platform__components_component_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_platform__components_component_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_platform__components_component_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /components/component/state (container)

    YANG Description: Operational state data for each component
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /components/component/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for each component
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_platform__components_component_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_platform__components_component_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_platform__components_component_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_properties(self):
    """
    Getter method for properties, mapped from YANG variable /components/component/properties (container)

    YANG Description: Enclosing container 
    """
    return self.__properties
      
  def _set_properties(self, v, load=False):
    """
    Setter method for properties, mapped from YANG variable /components/component/properties (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_properties is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_properties() directly.

    YANG Description: Enclosing container 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_properties_openconfig_platform__components_component_properties, is_container='container', yang_name="properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """properties must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_properties_openconfig_platform__components_component_properties, is_container='container', yang_name="properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__properties = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_properties(self):
    self.__properties = YANGDynClass(base=yc_properties_openconfig_platform__components_component_properties, is_container='container', yang_name="properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_subcomponents(self):
    """
    Getter method for subcomponents, mapped from YANG variable /components/component/subcomponents (container)

    YANG Description: Enclosing container for subcomponent references
    """
    return self.__subcomponents
      
  def _set_subcomponents(self, v, load=False):
    """
    Setter method for subcomponents, mapped from YANG variable /components/component/subcomponents (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subcomponents is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subcomponents() directly.

    YANG Description: Enclosing container for subcomponent references
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_subcomponents_openconfig_platform__components_component_subcomponents, is_container='container', yang_name="subcomponents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subcomponents must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_subcomponents_openconfig_platform__components_component_subcomponents, is_container='container', yang_name="subcomponents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__subcomponents = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subcomponents(self):
    self.__subcomponents = YANGDynClass(base=yc_subcomponents_openconfig_platform__components_component_subcomponents, is_container='container', yang_name="subcomponents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_chassis(self):
    """
    Getter method for chassis, mapped from YANG variable /components/component/chassis (container)

    YANG Description: Data for chassis components
    """
    return self.__chassis
      
  def _set_chassis(self, v, load=False):
    """
    Setter method for chassis, mapped from YANG variable /components/component/chassis (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_chassis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_chassis() directly.

    YANG Description: Data for chassis components
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_chassis_openconfig_platform__components_component_chassis, is_container='container', yang_name="chassis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """chassis must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_chassis_openconfig_platform__components_component_chassis, is_container='container', yang_name="chassis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__chassis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_chassis(self):
    self.__chassis = YANGDynClass(base=yc_chassis_openconfig_platform__components_component_chassis, is_container='container', yang_name="chassis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /components/component/port (container)

    YANG Description: Data for physical port components
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /components/component/port (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: Data for physical port components
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_port_openconfig_platform__components_component_port, is_container='container', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_port_openconfig_platform__components_component_port, is_container='container', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=yc_port_openconfig_platform__components_component_port, is_container='container', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_power_supply(self):
    """
    Getter method for power_supply, mapped from YANG variable /components/component/power_supply (container)

    YANG Description: Data for power supply components
    """
    return self.__power_supply
      
  def _set_power_supply(self, v, load=False):
    """
    Setter method for power_supply, mapped from YANG variable /components/component/power_supply (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_power_supply is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_power_supply() directly.

    YANG Description: Data for power supply components
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_power_supply_openconfig_platform__components_component_power_supply, is_container='container', yang_name="power-supply", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """power_supply must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_power_supply_openconfig_platform__components_component_power_supply, is_container='container', yang_name="power-supply", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__power_supply = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_power_supply(self):
    self.__power_supply = YANGDynClass(base=yc_power_supply_openconfig_platform__components_component_power_supply, is_container='container', yang_name="power-supply", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_fan(self):
    """
    Getter method for fan, mapped from YANG variable /components/component/fan (container)

    YANG Description: Data for fan components
    """
    return self.__fan
      
  def _set_fan(self, v, load=False):
    """
    Setter method for fan, mapped from YANG variable /components/component/fan (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fan() directly.

    YANG Description: Data for fan components
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_fan_openconfig_platform__components_component_fan, is_container='container', yang_name="fan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fan must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_fan_openconfig_platform__components_component_fan, is_container='container', yang_name="fan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__fan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fan(self):
    self.__fan = YANGDynClass(base=yc_fan_openconfig_platform__components_component_fan, is_container='container', yang_name="fan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_fabric(self):
    """
    Getter method for fabric, mapped from YANG variable /components/component/fabric (container)

    YANG Description: Data for fabric components
    """
    return self.__fabric
      
  def _set_fabric(self, v, load=False):
    """
    Setter method for fabric, mapped from YANG variable /components/component/fabric (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fabric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fabric() directly.

    YANG Description: Data for fabric components
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_fabric_openconfig_platform__components_component_fabric, is_container='container', yang_name="fabric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fabric must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_fabric_openconfig_platform__components_component_fabric, is_container='container', yang_name="fabric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__fabric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fabric(self):
    self.__fabric = YANGDynClass(base=yc_fabric_openconfig_platform__components_component_fabric, is_container='container', yang_name="fabric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_storage(self):
    """
    Getter method for storage, mapped from YANG variable /components/component/storage (container)

    YANG Description: Data for storage components
    """
    return self.__storage
      
  def _set_storage(self, v, load=False):
    """
    Setter method for storage, mapped from YANG variable /components/component/storage (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_storage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_storage() directly.

    YANG Description: Data for storage components
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_storage_openconfig_platform__components_component_storage, is_container='container', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """storage must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_storage_openconfig_platform__components_component_storage, is_container='container', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__storage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_storage(self):
    self.__storage = YANGDynClass(base=yc_storage_openconfig_platform__components_component_storage, is_container='container', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_cpu(self):
    """
    Getter method for cpu, mapped from YANG variable /components/component/cpu (container)

    YANG Description: Data for cpu components
    """
    return self.__cpu
      
  def _set_cpu(self, v, load=False):
    """
    Setter method for cpu, mapped from YANG variable /components/component/cpu (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu() directly.

    YANG Description: Data for cpu components
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_cpu_openconfig_platform__components_component_cpu, is_container='container', yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_cpu_openconfig_platform__components_component_cpu, is_container='container', yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__cpu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu(self):
    self.__cpu = YANGDynClass(base=yc_cpu_openconfig_platform__components_component_cpu, is_container='container', yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_integrated_circuit(self):
    """
    Getter method for integrated_circuit, mapped from YANG variable /components/component/integrated_circuit (container)

    YANG Description: Data for chip components, such as ASIC, NPUs, etc.
    """
    return self.__integrated_circuit
      
  def _set_integrated_circuit(self, v, load=False):
    """
    Setter method for integrated_circuit, mapped from YANG variable /components/component/integrated_circuit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_integrated_circuit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_integrated_circuit() directly.

    YANG Description: Data for chip components, such as ASIC, NPUs, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_integrated_circuit_openconfig_platform__components_component_integrated_circuit, is_container='container', yang_name="integrated-circuit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """integrated_circuit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_integrated_circuit_openconfig_platform__components_component_integrated_circuit, is_container='container', yang_name="integrated-circuit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__integrated_circuit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_integrated_circuit(self):
    self.__integrated_circuit = YANGDynClass(base=yc_integrated_circuit_openconfig_platform__components_component_integrated_circuit, is_container='container', yang_name="integrated-circuit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_backplane(self):
    """
    Getter method for backplane, mapped from YANG variable /components/component/backplane (container)

    YANG Description: Data for backplane components
    """
    return self.__backplane
      
  def _set_backplane(self, v, load=False):
    """
    Setter method for backplane, mapped from YANG variable /components/component/backplane (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_backplane is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_backplane() directly.

    YANG Description: Data for backplane components
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_backplane_openconfig_platform__components_component_backplane, is_container='container', yang_name="backplane", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """backplane must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_backplane_openconfig_platform__components_component_backplane, is_container='container', yang_name="backplane", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__backplane = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_backplane(self):
    self.__backplane = YANGDynClass(base=yc_backplane_openconfig_platform__components_component_backplane, is_container='container', yang_name="backplane", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_transceiver(self):
    """
    Getter method for transceiver, mapped from YANG variable /components/component/transceiver (container)

    YANG Description: Top-level container for client port transceiver data
    """
    return self.__transceiver
      
  def _set_transceiver(self, v, load=False):
    """
    Setter method for transceiver, mapped from YANG variable /components/component/transceiver (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transceiver is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transceiver() directly.

    YANG Description: Top-level container for client port transceiver data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_transceiver_openconfig_platform__components_component_transceiver, is_container='container', yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transceiver must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_transceiver_openconfig_platform__components_component_transceiver, is_container='container', yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)""",
        })

    self.__transceiver = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transceiver(self):
    self.__transceiver = YANGDynClass(base=yc_transceiver_openconfig_platform__components_component_transceiver, is_container='container', yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/transceiver', defining_module='openconfig-platform-transceiver', yang_type='container', is_config=True)


  def _get_optical_channel(self):
    """
    Getter method for optical_channel, mapped from YANG variable /components/component/optical_channel (container)

    YANG Description: Enclosing container for the list of optical channels
    """
    return self.__optical_channel
      
  def _set_optical_channel(self, v, load=False):
    """
    Setter method for optical_channel, mapped from YANG variable /components/component/optical_channel (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_channel() directly.

    YANG Description: Enclosing container for the list of optical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_optical_channel_openconfig_platform__components_component_optical_channel, is_container='container', yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_channel must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_optical_channel_openconfig_platform__components_component_optical_channel, is_container='container', yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__optical_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_channel(self):
    self.__optical_channel = YANGDynClass(base=yc_optical_channel_openconfig_platform__components_component_optical_channel, is_container='container', yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_linecard(self):
    """
    Getter method for linecard, mapped from YANG variable /components/component/linecard (container)

    YANG Description: Top-level container for linecard data
    """
    return self.__linecard
      
  def _set_linecard(self, v, load=False):
    """
    Setter method for linecard, mapped from YANG variable /components/component/linecard (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_linecard is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_linecard() directly.

    YANG Description: Top-level container for linecard data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_linecard_openconfig_platform__components_component_linecard, is_container='container', yang_name="linecard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """linecard must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_linecard_openconfig_platform__components_component_linecard, is_container='container', yang_name="linecard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='container', is_config=True)""",
        })

    self.__linecard = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_linecard(self):
    self.__linecard = YANGDynClass(base=yc_linecard_openconfig_platform__components_component_linecard, is_container='container', yang_name="linecard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform/linecard', defining_module='openconfig-platform-linecard', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  properties = __builtin__.property(_get_properties, _set_properties)
  subcomponents = __builtin__.property(_get_subcomponents, _set_subcomponents)
  chassis = __builtin__.property(_get_chassis, _set_chassis)
  port = __builtin__.property(_get_port, _set_port)
  power_supply = __builtin__.property(_get_power_supply, _set_power_supply)
  fan = __builtin__.property(_get_fan, _set_fan)
  fabric = __builtin__.property(_get_fabric, _set_fabric)
  storage = __builtin__.property(_get_storage, _set_storage)
  cpu = __builtin__.property(_get_cpu, _set_cpu)
  integrated_circuit = __builtin__.property(_get_integrated_circuit, _set_integrated_circuit)
  backplane = __builtin__.property(_get_backplane, _set_backplane)
  transceiver = __builtin__.property(_get_transceiver, _set_transceiver)
  optical_channel = __builtin__.property(_get_optical_channel, _set_optical_channel)
  linecard = __builtin__.property(_get_linecard, _set_linecard)


  _pyangbind_elements = OrderedDict([('name', name), ('config', config), ('state', state), ('properties', properties), ('subcomponents', subcomponents), ('chassis', chassis), ('port', port), ('power_supply', power_supply), ('fan', fan), ('fabric', fabric), ('storage', storage), ('cpu', cpu), ('integrated_circuit', integrated_circuit), ('backplane', backplane), ('transceiver', transceiver), ('optical_channel', optical_channel), ('linecard', linecard), ])


class yc_components_openconfig_platform__components(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for the components in the system.
  """
  __slots__ = ('_path_helper', '_extmethods', '__component',)

  _yang_name = 'components'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__component = YANGDynClass(base=YANGListType("name",yc_component_openconfig_platform__components_component, yang_name="component", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'components']

  def _get_component(self):
    """
    Getter method for component, mapped from YANG variable /components/component (list)

    YANG Description: List of components, keyed by component name.
    """
    return self.__component
      
  def _set_component(self, v, load=False):
    """
    Setter method for component, mapped from YANG variable /components/component (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_component is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_component() directly.

    YANG Description: List of components, keyed by component name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_component_openconfig_platform__components_component, yang_name="component", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """component must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_component_openconfig_platform__components_component, yang_name="component", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)""",
        })

    self.__component = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_component(self):
    self.__component = YANGDynClass(base=YANGListType("name",yc_component_openconfig_platform__components_component, yang_name="component", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)

  component = __builtin__.property(_get_component, _set_component)


  _pyangbind_elements = OrderedDict([('component', component), ])


class openconfig_platform(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /openconfig-platform. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a data model for representing a system
component inventory, which can include hardware or software
elements arranged in an arbitrary structure. The primary
relationship supported by the model is containment, e.g.,
components containing subcomponents.

It is expected that this model reflects every field replacable
unit on the device at a minimum (i.e., additional information
may be supplied about non-replacable components).

Every element in the inventory is termed a 'component' with each
component expected to have a unique name and type, and optionally
a unique system-assigned identifier and FRU number.  The
uniqueness is guaranteed by the system within the device.

Components may have properties defined by the system that are
modeled as a list of key-value pairs. These may or may not be
user-configurable.  The model provides a flag for the system
to optionally indicate which properties are user configurable.

Each component also has a list of 'subcomponents' which are
references to other components. Appearance in a list of
subcomponents indicates a containment relationship as described
above.  For example, a linecard component may have a list of
references to port components that reside on the linecard.

This schema is generic to allow devices to express their own
platform-specific structure.  It may be augmented by additional
component type-specific schemas that provide a common structure
for well-known component types.  In these cases, the system is
expected to populate the common component schema, and may
optionally also represent the component and its properties in the
generic structure.

The properties for each component may include dynamic values,
e.g., in the 'state' part of the schema.  For example, a CPU
component may report its utilization, temperature, or other
physical properties.  The intent is to capture all platform-
specific physical data in one location, including inventory
(presence or absence of a component) and state (physical
attributes or status).
  """
  __slots__ = ('_path_helper', '_extmethods', '__components',)

  _yang_name = 'openconfig-platform'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__components = YANGDynClass(base=yc_components_openconfig_platform__components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_components(self):
    """
    Getter method for components, mapped from YANG variable /components (container)

    YANG Description: Enclosing container for the components in the system.
    """
    return self.__components
      
  def _set_components(self, v, load=False):
    """
    Setter method for components, mapped from YANG variable /components (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_components is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_components() directly.

    YANG Description: Enclosing container for the components in the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_components_openconfig_platform__components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """components must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_components_openconfig_platform__components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__components = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_components(self):
    self.__components = YANGDynClass(base=yc_components_openconfig_platform__components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)

  components = __builtin__.property(_get_components, _set_components)


  _pyangbind_elements = OrderedDict([('components', components), ])


class yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for logical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__description','__admin_state','__rate_class','__trib_protocol','__logical_channel_type','__loopback_mode','__test_signal',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)
    self.__trib_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_OTU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_1GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU1E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_WAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC768': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_10GE_WAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM16': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC192': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_1GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM16': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_100GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM256': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_LAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_10GE_LAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC48': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC192': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_40GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_100G_MLG': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM256': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_40GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC768': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100G_MLG': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM64': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM64': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU1E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC48': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)
    self.__test_signal = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    self.__loopback_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'TERMINAL': {}, u'NONE': {}, u'FACILITY': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=True)
    self.__admin_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MAINT': {}, u'ENABLED': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=True)
    self.__rate_class = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:TRIB_RATE_800G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_40G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_800G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_600G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_600G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1000G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_900G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_300G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_400G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_400G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_10G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_700G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_250G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_700G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_900G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_200G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_40G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_200G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_150G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_150G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_500G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1000G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_10G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_250G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_300G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_500G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)
    self.__logical_channel_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_ETHERNET': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ETHERNET': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'config']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/config/index (uint32)

    YANG Description: Index of the current logical channel
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/config/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of the current logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/config/description (string)

    YANG Description: Description of the logical channel
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/config/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)


  def _get_admin_state(self):
    """
    Getter method for admin_state, mapped from YANG variable /terminal_device/logical_channels/channel/config/admin_state (oc-opt-types:admin-state-type)

    YANG Description: Sets the admin state of the logical channel
    """
    return self.__admin_state
      
  def _set_admin_state(self, v, load=False):
    """
    Setter method for admin_state, mapped from YANG variable /terminal_device/logical_channels/channel/config/admin_state (oc-opt-types:admin-state-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_state() directly.

    YANG Description: Sets the admin state of the logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MAINT': {}, u'ENABLED': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_state must be of a type compatible with oc-opt-types:admin-state-type""",
          'defined-type': "oc-opt-types:admin-state-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MAINT': {}, u'ENABLED': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=True)""",
        })

    self.__admin_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_state(self):
    self.__admin_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MAINT': {}, u'ENABLED': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=True)


  def _get_rate_class(self):
    """
    Getter method for rate_class, mapped from YANG variable /terminal_device/logical_channels/channel/config/rate_class (identityref)

    YANG Description: Rounded bit rate of the tributary signal. Exact bit rate
will be refined by protocol selection.
    """
    return self.__rate_class
      
  def _set_rate_class(self, v, load=False):
    """
    Setter method for rate_class, mapped from YANG variable /terminal_device/logical_channels/channel/config/rate_class (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rate_class is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rate_class() directly.

    YANG Description: Rounded bit rate of the tributary signal. Exact bit rate
will be refined by protocol selection.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:TRIB_RATE_800G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_40G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_800G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_600G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_600G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1000G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_900G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_300G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_400G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_400G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_10G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_700G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_250G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_700G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_900G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_200G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_40G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_200G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_150G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_150G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_500G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1000G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_10G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_250G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_300G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_500G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rate_class must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:TRIB_RATE_800G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_40G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_800G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_600G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_600G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1000G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_900G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_300G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_400G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_400G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_10G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_700G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_250G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_700G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_900G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_200G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_40G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_200G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_150G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_150G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_500G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1000G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_10G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_250G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_300G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_500G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)""",
        })

    self.__rate_class = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rate_class(self):
    self.__rate_class = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:TRIB_RATE_800G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_40G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_800G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_600G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_600G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1000G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_900G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_300G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_400G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_400G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_10G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_700G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_250G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_700G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_900G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_200G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_40G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_200G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_150G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_150G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_500G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1000G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_10G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_250G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_300G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_500G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)


  def _get_trib_protocol(self):
    """
    Getter method for trib_protocol, mapped from YANG variable /terminal_device/logical_channels/channel/config/trib_protocol (identityref)

    YANG Description: Protocol framing of the tributary signal. If this
LogicalChannel is directly connected to a Client-Port or
Optical-Channel, this is the protocol of the associated port.
If the LogicalChannel is connected to other LogicalChannels,
the TributaryProtocol of the LogicalChannels will define a
specific mapping/demapping or multiplexing/demultiplexing
function.

Not all protocols are valid, depending on the value
of trib-rate-class.  The expectation is that the NMS
will validate that a correct combination of rate class
and protocol are specfied.  Basic combinations are:

rate class: 1G
protocols: 1GE

rate class: 2.5G
protocols: OC48, STM16

rate class: 10G
protocols:  10GE LAN, 10GE WAN, OC192, STM64, OTU2, OTU2e,
           OTU1e, ODU2, ODU2e, ODU1e

rate class: 40G
protocols:  40GE, OC768, STM256, OTU3, ODU3

rate class: 100G
protocols:  100GE, 100G MLG, OTU4, OTUCn, ODU4
    """
    return self.__trib_protocol
      
  def _set_trib_protocol(self, v, load=False):
    """
    Setter method for trib_protocol, mapped from YANG variable /terminal_device/logical_channels/channel/config/trib_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trib_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trib_protocol() directly.

    YANG Description: Protocol framing of the tributary signal. If this
LogicalChannel is directly connected to a Client-Port or
Optical-Channel, this is the protocol of the associated port.
If the LogicalChannel is connected to other LogicalChannels,
the TributaryProtocol of the LogicalChannels will define a
specific mapping/demapping or multiplexing/demultiplexing
function.

Not all protocols are valid, depending on the value
of trib-rate-class.  The expectation is that the NMS
will validate that a correct combination of rate class
and protocol are specfied.  Basic combinations are:

rate class: 1G
protocols: 1GE

rate class: 2.5G
protocols: OC48, STM16

rate class: 10G
protocols:  10GE LAN, 10GE WAN, OC192, STM64, OTU2, OTU2e,
           OTU1e, ODU2, ODU2e, ODU1e

rate class: 40G
protocols:  40GE, OC768, STM256, OTU3, ODU3

rate class: 100G
protocols:  100GE, 100G MLG, OTU4, OTUCn, ODU4
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_OTU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_1GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU1E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_WAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC768': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_10GE_WAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM16': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC192': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_1GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM16': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_100GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM256': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_LAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_10GE_LAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC48': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC192': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_40GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_100G_MLG': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM256': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_40GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC768': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100G_MLG': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM64': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM64': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU1E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC48': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trib_protocol must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_OTU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_1GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU1E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_WAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC768': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_10GE_WAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM16': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC192': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_1GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM16': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_100GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM256': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_LAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_10GE_LAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC48': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC192': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_40GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_100G_MLG': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM256': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_40GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC768': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100G_MLG': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM64': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM64': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU1E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC48': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)""",
        })

    self.__trib_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trib_protocol(self):
    self.__trib_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_OTU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_1GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU1E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_WAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC768': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_10GE_WAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM16': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC192': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_1GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM16': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_100GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM256': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_LAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_10GE_LAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC48': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC192': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_40GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_100G_MLG': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM256': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_40GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC768': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100G_MLG': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM64': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM64': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU1E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC48': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)


  def _get_logical_channel_type(self):
    """
    Getter method for logical_channel_type, mapped from YANG variable /terminal_device/logical_channels/channel/config/logical_channel_type (identityref)

    YANG Description: The type / stage of the logical element determines the
configuration and operational state parameters (PMs)
available for the logical element
    """
    return self.__logical_channel_type
      
  def _set_logical_channel_type(self, v, load=False):
    """
    Setter method for logical_channel_type, mapped from YANG variable /terminal_device/logical_channels/channel/config/logical_channel_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_channel_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_channel_type() directly.

    YANG Description: The type / stage of the logical element determines the
configuration and operational state parameters (PMs)
available for the logical element
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_ETHERNET': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ETHERNET': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_channel_type must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_ETHERNET': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ETHERNET': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)""",
        })

    self.__logical_channel_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_channel_type(self):
    self.__logical_channel_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_ETHERNET': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ETHERNET': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)


  def _get_loopback_mode(self):
    """
    Getter method for loopback_mode, mapped from YANG variable /terminal_device/logical_channels/channel/config/loopback_mode (oc-opt-types:loopback-mode-type)

    YANG Description: Sets the loopback type on the logical channel. Setting the
mode to something besides NONE activates the loopback in
the specified mode.
    """
    return self.__loopback_mode
      
  def _set_loopback_mode(self, v, load=False):
    """
    Setter method for loopback_mode, mapped from YANG variable /terminal_device/logical_channels/channel/config/loopback_mode (oc-opt-types:loopback-mode-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loopback_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loopback_mode() directly.

    YANG Description: Sets the loopback type on the logical channel. Setting the
mode to something besides NONE activates the loopback in
the specified mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'TERMINAL': {}, u'NONE': {}, u'FACILITY': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loopback_mode must be of a type compatible with oc-opt-types:loopback-mode-type""",
          'defined-type': "oc-opt-types:loopback-mode-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'TERMINAL': {}, u'NONE': {}, u'FACILITY': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=True)""",
        })

    self.__loopback_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loopback_mode(self):
    self.__loopback_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'TERMINAL': {}, u'NONE': {}, u'FACILITY': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=True)


  def _get_test_signal(self):
    """
    Getter method for test_signal, mapped from YANG variable /terminal_device/logical_channels/channel/config/test_signal (boolean)

    YANG Description: When enabled the logical channel's DSP will generate a pseudo
randmon bit stream (PRBS) which can be used during testing.
    """
    return self.__test_signal
      
  def _set_test_signal(self, v, load=False):
    """
    Setter method for test_signal, mapped from YANG variable /terminal_device/logical_channels/channel/config/test_signal (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_test_signal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_test_signal() directly.

    YANG Description: When enabled the logical channel's DSP will generate a pseudo
randmon bit stream (PRBS) which can be used during testing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """test_signal must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)""",
        })

    self.__test_signal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_test_signal(self):
    self.__test_signal = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)

  index = __builtin__.property(_get_index, _set_index)
  description = __builtin__.property(_get_description, _set_description)
  admin_state = __builtin__.property(_get_admin_state, _set_admin_state)
  rate_class = __builtin__.property(_get_rate_class, _set_rate_class)
  trib_protocol = __builtin__.property(_get_trib_protocol, _set_trib_protocol)
  logical_channel_type = __builtin__.property(_get_logical_channel_type, _set_logical_channel_type)
  loopback_mode = __builtin__.property(_get_loopback_mode, _set_loopback_mode)
  test_signal = __builtin__.property(_get_test_signal, _set_test_signal)


  _pyangbind_elements = OrderedDict([('index', index), ('description', description), ('admin_state', admin_state), ('rate_class', rate_class), ('trib_protocol', trib_protocol), ('logical_channel_type', logical_channel_type), ('loopback_mode', loopback_mode), ('test_signal', test_signal), ])


class yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for logical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__description','__admin_state','__rate_class','__trib_protocol','__logical_channel_type','__loopback_mode','__test_signal','__link_state',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    self.__trib_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_OTU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_1GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU1E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_WAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC768': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_10GE_WAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM16': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC192': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_1GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM16': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_100GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM256': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_LAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_10GE_LAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC48': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC192': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_40GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_100G_MLG': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM256': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_40GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC768': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100G_MLG': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM64': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM64': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU1E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC48': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    self.__test_signal = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__link_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'DOWN': {}, u'TESTING': {}, u'UP': {}},), is_leaf=True, yang_name="link-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)
    self.__loopback_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'TERMINAL': {}, u'NONE': {}, u'FACILITY': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=False)
    self.__admin_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MAINT': {}, u'ENABLED': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=False)
    self.__rate_class = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:TRIB_RATE_800G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_40G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_800G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_600G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_600G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1000G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_900G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_300G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_400G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_400G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_10G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_700G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_250G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_700G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_900G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_200G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_40G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_200G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_150G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_150G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_500G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1000G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_10G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_250G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_300G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_500G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    self.__logical_channel_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_ETHERNET': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ETHERNET': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'state']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/state/index (uint32)

    YANG Description: Index of the current logical channel
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/state/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of the current logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/state/description (string)

    YANG Description: Description of the logical channel
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/state/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_admin_state(self):
    """
    Getter method for admin_state, mapped from YANG variable /terminal_device/logical_channels/channel/state/admin_state (oc-opt-types:admin-state-type)

    YANG Description: Sets the admin state of the logical channel
    """
    return self.__admin_state
      
  def _set_admin_state(self, v, load=False):
    """
    Setter method for admin_state, mapped from YANG variable /terminal_device/logical_channels/channel/state/admin_state (oc-opt-types:admin-state-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_state() directly.

    YANG Description: Sets the admin state of the logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MAINT': {}, u'ENABLED': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_state must be of a type compatible with oc-opt-types:admin-state-type""",
          'defined-type': "oc-opt-types:admin-state-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MAINT': {}, u'ENABLED': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=False)""",
        })

    self.__admin_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_state(self):
    self.__admin_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MAINT': {}, u'ENABLED': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=False)


  def _get_rate_class(self):
    """
    Getter method for rate_class, mapped from YANG variable /terminal_device/logical_channels/channel/state/rate_class (identityref)

    YANG Description: Rounded bit rate of the tributary signal. Exact bit rate
will be refined by protocol selection.
    """
    return self.__rate_class
      
  def _set_rate_class(self, v, load=False):
    """
    Setter method for rate_class, mapped from YANG variable /terminal_device/logical_channels/channel/state/rate_class (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rate_class is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rate_class() directly.

    YANG Description: Rounded bit rate of the tributary signal. Exact bit rate
will be refined by protocol selection.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:TRIB_RATE_800G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_40G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_800G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_600G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_600G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1000G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_900G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_300G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_400G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_400G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_10G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_700G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_250G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_700G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_900G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_200G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_40G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_200G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_150G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_150G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_500G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1000G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_10G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_250G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_300G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_500G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rate_class must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:TRIB_RATE_800G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_40G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_800G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_600G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_600G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1000G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_900G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_300G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_400G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_400G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_10G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_700G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_250G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_700G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_900G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_200G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_40G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_200G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_150G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_150G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_500G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1000G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_10G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_250G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_300G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_500G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)""",
        })

    self.__rate_class = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rate_class(self):
    self.__rate_class = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:TRIB_RATE_800G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_40G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_800G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_600G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_600G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1000G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_900G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_300G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_400G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_400G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_10G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_700G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_250G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_700G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_900G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_200G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_40G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_200G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_150G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_150G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_500G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_1000G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_10G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_100G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_250G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_RATE_300G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_500G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)


  def _get_trib_protocol(self):
    """
    Getter method for trib_protocol, mapped from YANG variable /terminal_device/logical_channels/channel/state/trib_protocol (identityref)

    YANG Description: Protocol framing of the tributary signal. If this
LogicalChannel is directly connected to a Client-Port or
Optical-Channel, this is the protocol of the associated port.
If the LogicalChannel is connected to other LogicalChannels,
the TributaryProtocol of the LogicalChannels will define a
specific mapping/demapping or multiplexing/demultiplexing
function.

Not all protocols are valid, depending on the value
of trib-rate-class.  The expectation is that the NMS
will validate that a correct combination of rate class
and protocol are specfied.  Basic combinations are:

rate class: 1G
protocols: 1GE

rate class: 2.5G
protocols: OC48, STM16

rate class: 10G
protocols:  10GE LAN, 10GE WAN, OC192, STM64, OTU2, OTU2e,
           OTU1e, ODU2, ODU2e, ODU1e

rate class: 40G
protocols:  40GE, OC768, STM256, OTU3, ODU3

rate class: 100G
protocols:  100GE, 100G MLG, OTU4, OTUCn, ODU4
    """
    return self.__trib_protocol
      
  def _set_trib_protocol(self, v, load=False):
    """
    Setter method for trib_protocol, mapped from YANG variable /terminal_device/logical_channels/channel/state/trib_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trib_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trib_protocol() directly.

    YANG Description: Protocol framing of the tributary signal. If this
LogicalChannel is directly connected to a Client-Port or
Optical-Channel, this is the protocol of the associated port.
If the LogicalChannel is connected to other LogicalChannels,
the TributaryProtocol of the LogicalChannels will define a
specific mapping/demapping or multiplexing/demultiplexing
function.

Not all protocols are valid, depending on the value
of trib-rate-class.  The expectation is that the NMS
will validate that a correct combination of rate class
and protocol are specfied.  Basic combinations are:

rate class: 1G
protocols: 1GE

rate class: 2.5G
protocols: OC48, STM16

rate class: 10G
protocols:  10GE LAN, 10GE WAN, OC192, STM64, OTU2, OTU2e,
           OTU1e, ODU2, ODU2e, ODU1e

rate class: 40G
protocols:  40GE, OC768, STM256, OTU3, ODU3

rate class: 100G
protocols:  100GE, 100G MLG, OTU4, OTUCn, ODU4
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_OTU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_1GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU1E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_WAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC768': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_10GE_WAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM16': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC192': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_1GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM16': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_100GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM256': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_LAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_10GE_LAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC48': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC192': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_40GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_100G_MLG': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM256': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_40GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC768': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100G_MLG': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM64': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM64': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU1E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC48': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trib_protocol must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_OTU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_1GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU1E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_WAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC768': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_10GE_WAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM16': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC192': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_1GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM16': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_100GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM256': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_LAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_10GE_LAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC48': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC192': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_40GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_100G_MLG': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM256': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_40GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC768': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100G_MLG': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM64': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM64': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU1E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC48': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)""",
        })

    self.__trib_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trib_protocol(self):
    self.__trib_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_OTU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_1GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU1E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_WAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC768': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_10GE_WAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM16': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTUCN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC192': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_1GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU2E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM16': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_100GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM256': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_LAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_10GE_LAN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC48': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OC192': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_40GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_100G_MLG': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU4': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM256': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_40GE': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC768': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100G_MLG': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU3': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ODU2': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM64': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_STM64': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU1E': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC48': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)


  def _get_logical_channel_type(self):
    """
    Getter method for logical_channel_type, mapped from YANG variable /terminal_device/logical_channels/channel/state/logical_channel_type (identityref)

    YANG Description: The type / stage of the logical element determines the
configuration and operational state parameters (PMs)
available for the logical element
    """
    return self.__logical_channel_type
      
  def _set_logical_channel_type(self, v, load=False):
    """
    Setter method for logical_channel_type, mapped from YANG variable /terminal_device/logical_channels/channel/state/logical_channel_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_channel_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_channel_type() directly.

    YANG Description: The type / stage of the logical element determines the
configuration and operational state parameters (PMs)
available for the logical element
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_ETHERNET': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ETHERNET': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_channel_type must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_ETHERNET': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ETHERNET': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)""",
        })

    self.__logical_channel_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_channel_type(self):
    self.__logical_channel_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_ETHERNET': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_OTN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'PROT_ETHERNET': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTN': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)


  def _get_loopback_mode(self):
    """
    Getter method for loopback_mode, mapped from YANG variable /terminal_device/logical_channels/channel/state/loopback_mode (oc-opt-types:loopback-mode-type)

    YANG Description: Sets the loopback type on the logical channel. Setting the
mode to something besides NONE activates the loopback in
the specified mode.
    """
    return self.__loopback_mode
      
  def _set_loopback_mode(self, v, load=False):
    """
    Setter method for loopback_mode, mapped from YANG variable /terminal_device/logical_channels/channel/state/loopback_mode (oc-opt-types:loopback-mode-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loopback_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loopback_mode() directly.

    YANG Description: Sets the loopback type on the logical channel. Setting the
mode to something besides NONE activates the loopback in
the specified mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'TERMINAL': {}, u'NONE': {}, u'FACILITY': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loopback_mode must be of a type compatible with oc-opt-types:loopback-mode-type""",
          'defined-type': "oc-opt-types:loopback-mode-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'TERMINAL': {}, u'NONE': {}, u'FACILITY': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=False)""",
        })

    self.__loopback_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loopback_mode(self):
    self.__loopback_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'TERMINAL': {}, u'NONE': {}, u'FACILITY': {}},), default=six.text_type("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=False)


  def _get_test_signal(self):
    """
    Getter method for test_signal, mapped from YANG variable /terminal_device/logical_channels/channel/state/test_signal (boolean)

    YANG Description: When enabled the logical channel's DSP will generate a pseudo
randmon bit stream (PRBS) which can be used during testing.
    """
    return self.__test_signal
      
  def _set_test_signal(self, v, load=False):
    """
    Setter method for test_signal, mapped from YANG variable /terminal_device/logical_channels/channel/state/test_signal (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_test_signal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_test_signal() directly.

    YANG Description: When enabled the logical channel's DSP will generate a pseudo
randmon bit stream (PRBS) which can be used during testing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """test_signal must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)""",
        })

    self.__test_signal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_test_signal(self):
    self.__test_signal = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)


  def _get_link_state(self):
    """
    Getter method for link_state, mapped from YANG variable /terminal_device/logical_channels/channel/state/link_state (enumeration)

    YANG Description: Link-state of the Ethernet protocol on the logical channel,
SONET / SDH framed signal, etc.
    """
    return self.__link_state
      
  def _set_link_state(self, v, load=False):
    """
    Setter method for link_state, mapped from YANG variable /terminal_device/logical_channels/channel/state/link_state (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_state() directly.

    YANG Description: Link-state of the Ethernet protocol on the logical channel,
SONET / SDH framed signal, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'DOWN': {}, u'TESTING': {}, u'UP': {}},), is_leaf=True, yang_name="link-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_state must be of a type compatible with enumeration""",
          'defined-type': "openconfig-terminal-device:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'DOWN': {}, u'TESTING': {}, u'UP': {}},), is_leaf=True, yang_name="link-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)""",
        })

    self.__link_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_state(self):
    self.__link_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'DOWN': {}, u'TESTING': {}, u'UP': {}},), is_leaf=True, yang_name="link-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)

  index = __builtin__.property(_get_index)
  description = __builtin__.property(_get_description)
  admin_state = __builtin__.property(_get_admin_state)
  rate_class = __builtin__.property(_get_rate_class)
  trib_protocol = __builtin__.property(_get_trib_protocol)
  logical_channel_type = __builtin__.property(_get_logical_channel_type)
  loopback_mode = __builtin__.property(_get_loopback_mode)
  test_signal = __builtin__.property(_get_test_signal)
  link_state = __builtin__.property(_get_link_state)


  _pyangbind_elements = OrderedDict([('index', index), ('description', description), ('admin_state', admin_state), ('rate_class', rate_class), ('trib_protocol', trib_protocol), ('logical_channel_type', logical_channel_type), ('loopback_mode', loopback_mode), ('test_signal', test_signal), ('link_state', link_state), ])


class yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/otn/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for OTN protocol framing
  """
  __slots__ = ('_path_helper', '_extmethods', '__tti_msg_transmit','__tti_msg_expected','__tti_msg_auto','__tributary_slot_granularity',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tributary_slot_granularity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'TRIB_SLOT_5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_SLOT_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_SLOT_1.25G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_1.25G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="tributary-slot-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)
    self.__tti_msg_expected = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    self.__tti_msg_transmit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    self.__tti_msg_auto = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'otn', u'config']

  def _get_tti_msg_transmit(self):
    """
    Getter method for tti_msg_transmit, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config/tti_msg_transmit (string)

    YANG Description: Trail trace identifier (TTI) message transmitted
    """
    return self.__tti_msg_transmit
      
  def _set_tti_msg_transmit(self, v, load=False):
    """
    Setter method for tti_msg_transmit, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config/tti_msg_transmit (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tti_msg_transmit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tti_msg_transmit() directly.

    YANG Description: Trail trace identifier (TTI) message transmitted
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tti_msg_transmit must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)""",
        })

    self.__tti_msg_transmit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tti_msg_transmit(self):
    self.__tti_msg_transmit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)


  def _get_tti_msg_expected(self):
    """
    Getter method for tti_msg_expected, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config/tti_msg_expected (string)

    YANG Description: Trail trace identifier (TTI) message expected
    """
    return self.__tti_msg_expected
      
  def _set_tti_msg_expected(self, v, load=False):
    """
    Setter method for tti_msg_expected, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config/tti_msg_expected (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tti_msg_expected is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tti_msg_expected() directly.

    YANG Description: Trail trace identifier (TTI) message expected
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tti_msg_expected must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)""",
        })

    self.__tti_msg_expected = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tti_msg_expected(self):
    self.__tti_msg_expected = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)


  def _get_tti_msg_auto(self):
    """
    Getter method for tti_msg_auto, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config/tti_msg_auto (boolean)

    YANG Description: Trail trace identifier (TTI) transmit message automatically
created.  If true, then setting a custom transmit message
would be invalid.
    """
    return self.__tti_msg_auto
      
  def _set_tti_msg_auto(self, v, load=False):
    """
    Setter method for tti_msg_auto, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config/tti_msg_auto (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tti_msg_auto is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tti_msg_auto() directly.

    YANG Description: Trail trace identifier (TTI) transmit message automatically
created.  If true, then setting a custom transmit message
would be invalid.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tti_msg_auto must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)""",
        })

    self.__tti_msg_auto = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tti_msg_auto(self):
    self.__tti_msg_auto = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)


  def _get_tributary_slot_granularity(self):
    """
    Getter method for tributary_slot_granularity, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config/tributary_slot_granularity (identityref)

    YANG Description: Granularity value of OPUk or OPUCn tributary slots for OTN
signal allocation. The currently defined values follow the
existing ITU-T G.709 standard, which can be extended as
needed in future.
    """
    return self.__tributary_slot_granularity
      
  def _set_tributary_slot_granularity(self, v, load=False):
    """
    Setter method for tributary_slot_granularity, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config/tributary_slot_granularity (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tributary_slot_granularity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tributary_slot_granularity() directly.

    YANG Description: Granularity value of OPUk or OPUCn tributary slots for OTN
signal allocation. The currently defined values follow the
existing ITU-T G.709 standard, which can be extended as
needed in future.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'TRIB_SLOT_5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_SLOT_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_SLOT_1.25G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_1.25G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="tributary-slot-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tributary_slot_granularity must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'TRIB_SLOT_5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_SLOT_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_SLOT_1.25G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_1.25G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="tributary-slot-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)""",
        })

    self.__tributary_slot_granularity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tributary_slot_granularity(self):
    self.__tributary_slot_granularity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'TRIB_SLOT_5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_SLOT_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_SLOT_1.25G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_1.25G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="tributary-slot-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)

  tti_msg_transmit = __builtin__.property(_get_tti_msg_transmit, _set_tti_msg_transmit)
  tti_msg_expected = __builtin__.property(_get_tti_msg_expected, _set_tti_msg_expected)
  tti_msg_auto = __builtin__.property(_get_tti_msg_auto, _set_tti_msg_auto)
  tributary_slot_granularity = __builtin__.property(_get_tributary_slot_granularity, _set_tributary_slot_granularity)


  _pyangbind_elements = OrderedDict([('tti_msg_transmit', tti_msg_transmit), ('tti_msg_expected', tti_msg_expected), ('tti_msg_auto', tti_msg_auto), ('tributary_slot_granularity', tributary_slot_granularity), ])


class yc_pre_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_pre_fec_ber(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/otn/state/pre-fec-ber. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Bit error rate before forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'pre-fec-ber'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'otn', u'state', u'pre-fec-ber']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_post_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_post_fec_ber(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/otn/state/post-fec-ber. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Bit error rate after forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'post-fec-ber'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'otn', u'state', u'post-fec-ber']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/min (decimal64)

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_q_value_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_q_value(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/otn/state/q-value. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Quality value (factor) in dB of a channel with two
decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'q-value'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'otn', u'state', u'q-value']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/min (decimal64)

    YANG Description: The minimum value of the statistic over the time interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_esnr_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_esnr(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/otn/state/esnr. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Electrical signal to noise ratio. Baud rate
normalized signal to noise ratio based on
error vector magnitude in dB with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time',)

  _yang_name = 'esnr'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'otn', u'state', u'esnr']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/min (decimal64)

    YANG Description: The minimum value of the statistic over the time interval.
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/max (decimal64)

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the time
interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:stat-interval', is_config=False)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-types:timeticks64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)
  interval = __builtin__.property(_get_interval)
  min_time = __builtin__.property(_get_min_time)
  max_time = __builtin__.property(_get_max_time)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ])


class yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/otn/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for OTN protocol PMs, statistics,
etc.
  """
  __slots__ = ('_path_helper', '_extmethods', '__tti_msg_transmit','__tti_msg_expected','__tti_msg_auto','__tributary_slot_granularity','__tti_msg_recv','__rdi_msg','__errored_seconds','__severely_errored_seconds','__unavailable_seconds','__code_violations','__errored_blocks','__fec_uncorrectable_blocks','__fec_uncorrectable_words','__fec_corrected_bytes','__fec_corrected_bits','__background_block_errors','__pre_fec_ber','__post_fec_ber','__q_value','__esnr',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__fec_corrected_bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__tti_msg_recv = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-recv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__fec_corrected_bits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__pre_fec_ber = YANGDynClass(base=yc_pre_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__tti_msg_transmit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__tti_msg_expected = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__unavailable_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="unavailable-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__errored_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__code_violations = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="code-violations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__fec_uncorrectable_blocks = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__post_fec_ber = YANGDynClass(base=yc_post_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__fec_uncorrectable_words = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-words", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__q_value = YANGDynClass(base=yc_q_value_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__severely_errored_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="severely-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__errored_blocks = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errored-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__rdi_msg = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rdi-msg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__background_block_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="background-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__esnr = YANGDynClass(base=yc_esnr_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__tributary_slot_granularity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'TRIB_SLOT_5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_SLOT_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_SLOT_1.25G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_1.25G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="tributary-slot-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    self.__tti_msg_auto = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'otn', u'state']

  def _get_tti_msg_transmit(self):
    """
    Getter method for tti_msg_transmit, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_transmit (string)

    YANG Description: Trail trace identifier (TTI) message transmitted
    """
    return self.__tti_msg_transmit
      
  def _set_tti_msg_transmit(self, v, load=False):
    """
    Setter method for tti_msg_transmit, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_transmit (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tti_msg_transmit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tti_msg_transmit() directly.

    YANG Description: Trail trace identifier (TTI) message transmitted
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tti_msg_transmit must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__tti_msg_transmit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tti_msg_transmit(self):
    self.__tti_msg_transmit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_tti_msg_expected(self):
    """
    Getter method for tti_msg_expected, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_expected (string)

    YANG Description: Trail trace identifier (TTI) message expected
    """
    return self.__tti_msg_expected
      
  def _set_tti_msg_expected(self, v, load=False):
    """
    Setter method for tti_msg_expected, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_expected (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tti_msg_expected is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tti_msg_expected() directly.

    YANG Description: Trail trace identifier (TTI) message expected
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tti_msg_expected must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__tti_msg_expected = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tti_msg_expected(self):
    self.__tti_msg_expected = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_tti_msg_auto(self):
    """
    Getter method for tti_msg_auto, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_auto (boolean)

    YANG Description: Trail trace identifier (TTI) transmit message automatically
created.  If true, then setting a custom transmit message
would be invalid.
    """
    return self.__tti_msg_auto
      
  def _set_tti_msg_auto(self, v, load=False):
    """
    Setter method for tti_msg_auto, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_auto (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tti_msg_auto is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tti_msg_auto() directly.

    YANG Description: Trail trace identifier (TTI) transmit message automatically
created.  If true, then setting a custom transmit message
would be invalid.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tti_msg_auto must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)""",
        })

    self.__tti_msg_auto = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tti_msg_auto(self):
    self.__tti_msg_auto = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)


  def _get_tributary_slot_granularity(self):
    """
    Getter method for tributary_slot_granularity, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tributary_slot_granularity (identityref)

    YANG Description: Granularity value of OPUk or OPUCn tributary slots for OTN
signal allocation. The currently defined values follow the
existing ITU-T G.709 standard, which can be extended as
needed in future.
    """
    return self.__tributary_slot_granularity
      
  def _set_tributary_slot_granularity(self, v, load=False):
    """
    Setter method for tributary_slot_granularity, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tributary_slot_granularity (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tributary_slot_granularity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tributary_slot_granularity() directly.

    YANG Description: Granularity value of OPUk or OPUCn tributary slots for OTN
signal allocation. The currently defined values follow the
existing ITU-T G.709 standard, which can be extended as
needed in future.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'TRIB_SLOT_5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_SLOT_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_SLOT_1.25G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_1.25G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="tributary-slot-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tributary_slot_granularity must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'TRIB_SLOT_5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_SLOT_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_SLOT_1.25G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_1.25G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="tributary-slot-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)""",
        })

    self.__tributary_slot_granularity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tributary_slot_granularity(self):
    self.__tributary_slot_granularity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'TRIB_SLOT_5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_SLOT_2.5G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'TRIB_SLOT_1.25G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_SLOT_1.25G': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="tributary-slot-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)


  def _get_tti_msg_recv(self):
    """
    Getter method for tti_msg_recv, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_recv (string)

    YANG Description: Trail trace identifier (TTI) message received
    """
    return self.__tti_msg_recv
      
  def _set_tti_msg_recv(self, v, load=False):
    """
    Setter method for tti_msg_recv, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_recv (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tti_msg_recv is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tti_msg_recv() directly.

    YANG Description: Trail trace identifier (TTI) message received
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="tti-msg-recv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tti_msg_recv must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-recv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__tti_msg_recv = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tti_msg_recv(self):
    self.__tti_msg_recv = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tti-msg-recv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_rdi_msg(self):
    """
    Getter method for rdi_msg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/rdi_msg (string)

    YANG Description: Remote defect indication (RDI) message received
    """
    return self.__rdi_msg
      
  def _set_rdi_msg(self, v, load=False):
    """
    Setter method for rdi_msg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/rdi_msg (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rdi_msg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rdi_msg() directly.

    YANG Description: Remote defect indication (RDI) message received
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="rdi-msg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rdi_msg must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rdi-msg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__rdi_msg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rdi_msg(self):
    self.__rdi_msg = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rdi-msg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_errored_seconds(self):
    """
    Getter method for errored_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/errored_seconds (yang:counter64)

    YANG Description: The number of seconds that at least one errored blocks
occurs, at least one code violation occurs, loss of sync is
detected or loss of signal is detected
    """
    return self.__errored_seconds
      
  def _set_errored_seconds(self, v, load=False):
    """
    Setter method for errored_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/errored_seconds (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_errored_seconds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_errored_seconds() directly.

    YANG Description: The number of seconds that at least one errored blocks
occurs, at least one code violation occurs, loss of sync is
detected or loss of signal is detected
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """errored_seconds must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__errored_seconds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_errored_seconds(self):
    self.__errored_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_severely_errored_seconds(self):
    """
    Getter method for severely_errored_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/severely_errored_seconds (yang:counter64)

    YANG Description: The number of seconds that loss of frame is detected OR
the number of errored blocks, code violations, loss of sync
or loss of signal is detected exceeds a predefined
threshold
    """
    return self.__severely_errored_seconds
      
  def _set_severely_errored_seconds(self, v, load=False):
    """
    Setter method for severely_errored_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/severely_errored_seconds (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_severely_errored_seconds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_severely_errored_seconds() directly.

    YANG Description: The number of seconds that loss of frame is detected OR
the number of errored blocks, code violations, loss of sync
or loss of signal is detected exceeds a predefined
threshold
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="severely-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """severely_errored_seconds must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="severely-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__severely_errored_seconds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_severely_errored_seconds(self):
    self.__severely_errored_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="severely-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_unavailable_seconds(self):
    """
    Getter method for unavailable_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/unavailable_seconds (yang:counter64)

    YANG Description: The number of seconds during which the link is unavailable
    """
    return self.__unavailable_seconds
      
  def _set_unavailable_seconds(self, v, load=False):
    """
    Setter method for unavailable_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/unavailable_seconds (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unavailable_seconds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unavailable_seconds() directly.

    YANG Description: The number of seconds during which the link is unavailable
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="unavailable-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unavailable_seconds must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="unavailable-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__unavailable_seconds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unavailable_seconds(self):
    self.__unavailable_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="unavailable-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_code_violations(self):
    """
    Getter method for code_violations, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/code_violations (yang:counter64)

    YANG Description: For ethernet or fiberchannel links, the number of 8b/10b
coding violations. For SONET/SDH, the number of BIP (bit
interleaved parity) errors
    """
    return self.__code_violations
      
  def _set_code_violations(self, v, load=False):
    """
    Setter method for code_violations, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/code_violations (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_code_violations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_code_violations() directly.

    YANG Description: For ethernet or fiberchannel links, the number of 8b/10b
coding violations. For SONET/SDH, the number of BIP (bit
interleaved parity) errors
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="code-violations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """code_violations must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="code-violations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__code_violations = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_code_violations(self):
    self.__code_violations = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="code-violations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_errored_blocks(self):
    """
    Getter method for errored_blocks, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/errored_blocks (yang:counter64)

    YANG Description: The number of errored blocks. Error detection codes are
capable to detect whether one or more errors have occurred
in a given sequence of bits – the block. It is normally not
possible to determine the exact number of errored bits within
the block.
    """
    return self.__errored_blocks
      
  def _set_errored_blocks(self, v, load=False):
    """
    Setter method for errored_blocks, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/errored_blocks (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_errored_blocks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_errored_blocks() directly.

    YANG Description: The number of errored blocks. Error detection codes are
capable to detect whether one or more errors have occurred
in a given sequence of bits – the block. It is normally not
possible to determine the exact number of errored bits within
the block.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errored-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """errored_blocks must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errored-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__errored_blocks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_errored_blocks(self):
    self.__errored_blocks = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errored-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_fec_uncorrectable_blocks(self):
    """
    Getter method for fec_uncorrectable_blocks, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/fec_uncorrectable_blocks (yang:counter64)

    YANG Description: The number of blocks that were uncorrectable by the FEC
    """
    return self.__fec_uncorrectable_blocks
      
  def _set_fec_uncorrectable_blocks(self, v, load=False):
    """
    Setter method for fec_uncorrectable_blocks, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/fec_uncorrectable_blocks (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_uncorrectable_blocks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_uncorrectable_blocks() directly.

    YANG Description: The number of blocks that were uncorrectable by the FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_uncorrectable_blocks must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__fec_uncorrectable_blocks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_uncorrectable_blocks(self):
    self.__fec_uncorrectable_blocks = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_fec_uncorrectable_words(self):
    """
    Getter method for fec_uncorrectable_words, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/fec_uncorrectable_words (yang:counter64)

    YANG Description: The number of words that were uncorrectable by the FEC
    """
    return self.__fec_uncorrectable_words
      
  def _set_fec_uncorrectable_words(self, v, load=False):
    """
    Setter method for fec_uncorrectable_words, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/fec_uncorrectable_words (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_uncorrectable_words is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_uncorrectable_words() directly.

    YANG Description: The number of words that were uncorrectable by the FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-words", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_uncorrectable_words must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-words", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__fec_uncorrectable_words = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_uncorrectable_words(self):
    self.__fec_uncorrectable_words = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-words", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_fec_corrected_bytes(self):
    """
    Getter method for fec_corrected_bytes, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/fec_corrected_bytes (yang:counter64)

    YANG Description: The number of bytes that were corrected by the FEC
    """
    return self.__fec_corrected_bytes
      
  def _set_fec_corrected_bytes(self, v, load=False):
    """
    Setter method for fec_corrected_bytes, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/fec_corrected_bytes (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_corrected_bytes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_corrected_bytes() directly.

    YANG Description: The number of bytes that were corrected by the FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_corrected_bytes must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__fec_corrected_bytes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_corrected_bytes(self):
    self.__fec_corrected_bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_fec_corrected_bits(self):
    """
    Getter method for fec_corrected_bits, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/fec_corrected_bits (yang:counter64)

    YANG Description: The number of bits that were corrected by the FEC
    """
    return self.__fec_corrected_bits
      
  def _set_fec_corrected_bits(self, v, load=False):
    """
    Setter method for fec_corrected_bits, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/fec_corrected_bits (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_corrected_bits is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_corrected_bits() directly.

    YANG Description: The number of bits that were corrected by the FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_corrected_bits must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__fec_corrected_bits = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_corrected_bits(self):
    self.__fec_corrected_bits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_background_block_errors(self):
    """
    Getter method for background_block_errors, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/background_block_errors (yang:counter64)

    YANG Description: The number of background block errors
    """
    return self.__background_block_errors
      
  def _set_background_block_errors(self, v, load=False):
    """
    Setter method for background_block_errors, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/background_block_errors (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_background_block_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_background_block_errors() directly.

    YANG Description: The number of background block errors
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="background-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """background_block_errors must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="background-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__background_block_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_background_block_errors(self):
    self.__background_block_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="background-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_pre_fec_ber(self):
    """
    Getter method for pre_fec_ber, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber (container)

    YANG Description: Bit error rate before forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__pre_fec_ber
      
  def _set_pre_fec_ber(self, v, load=False):
    """
    Setter method for pre_fec_ber, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pre_fec_ber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pre_fec_ber() directly.

    YANG Description: Bit error rate before forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_pre_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pre_fec_ber must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_pre_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__pre_fec_ber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pre_fec_ber(self):
    self.__pre_fec_ber = YANGDynClass(base=yc_pre_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_post_fec_ber(self):
    """
    Getter method for post_fec_ber, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber (container)

    YANG Description: Bit error rate after forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__post_fec_ber
      
  def _set_post_fec_ber(self, v, load=False):
    """
    Setter method for post_fec_ber, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_post_fec_ber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_post_fec_ber() directly.

    YANG Description: Bit error rate after forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_post_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """post_fec_ber must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_post_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__post_fec_ber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_post_fec_ber(self):
    self.__post_fec_ber = YANGDynClass(base=yc_post_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_q_value(self):
    """
    Getter method for q_value, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value (container)

    YANG Description: Quality value (factor) in dB of a channel with two
decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    return self.__q_value
      
  def _set_q_value(self, v, load=False):
    """
    Setter method for q_value, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_q_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_q_value() directly.

    YANG Description: Quality value (factor) in dB of a channel with two
decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_q_value_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """q_value must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_q_value_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__q_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_q_value(self):
    self.__q_value = YANGDynClass(base=yc_q_value_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_esnr(self):
    """
    Getter method for esnr, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr (container)

    YANG Description: Electrical signal to noise ratio. Baud rate
normalized signal to noise ratio based on
error vector magnitude in dB with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    return self.__esnr
      
  def _set_esnr(self, v, load=False):
    """
    Setter method for esnr, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_esnr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_esnr() directly.

    YANG Description: Electrical signal to noise ratio. Baud rate
normalized signal to noise ratio based on
error vector magnitude in dB with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_esnr_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """esnr must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_esnr_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__esnr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_esnr(self):
    self.__esnr = YANGDynClass(base=yc_esnr_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

  tti_msg_transmit = __builtin__.property(_get_tti_msg_transmit)
  tti_msg_expected = __builtin__.property(_get_tti_msg_expected)
  tti_msg_auto = __builtin__.property(_get_tti_msg_auto)
  tributary_slot_granularity = __builtin__.property(_get_tributary_slot_granularity)
  tti_msg_recv = __builtin__.property(_get_tti_msg_recv)
  rdi_msg = __builtin__.property(_get_rdi_msg)
  errored_seconds = __builtin__.property(_get_errored_seconds)
  severely_errored_seconds = __builtin__.property(_get_severely_errored_seconds)
  unavailable_seconds = __builtin__.property(_get_unavailable_seconds)
  code_violations = __builtin__.property(_get_code_violations)
  errored_blocks = __builtin__.property(_get_errored_blocks)
  fec_uncorrectable_blocks = __builtin__.property(_get_fec_uncorrectable_blocks)
  fec_uncorrectable_words = __builtin__.property(_get_fec_uncorrectable_words)
  fec_corrected_bytes = __builtin__.property(_get_fec_corrected_bytes)
  fec_corrected_bits = __builtin__.property(_get_fec_corrected_bits)
  background_block_errors = __builtin__.property(_get_background_block_errors)
  pre_fec_ber = __builtin__.property(_get_pre_fec_ber)
  post_fec_ber = __builtin__.property(_get_post_fec_ber)
  q_value = __builtin__.property(_get_q_value)
  esnr = __builtin__.property(_get_esnr)


  _pyangbind_elements = OrderedDict([('tti_msg_transmit', tti_msg_transmit), ('tti_msg_expected', tti_msg_expected), ('tti_msg_auto', tti_msg_auto), ('tributary_slot_granularity', tributary_slot_granularity), ('tti_msg_recv', tti_msg_recv), ('rdi_msg', rdi_msg), ('errored_seconds', errored_seconds), ('severely_errored_seconds', severely_errored_seconds), ('unavailable_seconds', unavailable_seconds), ('code_violations', code_violations), ('errored_blocks', errored_blocks), ('fec_uncorrectable_blocks', fec_uncorrectable_blocks), ('fec_uncorrectable_words', fec_uncorrectable_words), ('fec_corrected_bytes', fec_corrected_bytes), ('fec_corrected_bits', fec_corrected_bits), ('background_block_errors', background_block_errors), ('pre_fec_ber', pre_fec_ber), ('post_fec_ber', post_fec_ber), ('q_value', q_value), ('esnr', esnr), ])


class yc_otn_openconfig_terminal_device__terminal_device_logical_channels_channel_otn(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/otn. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top level container for OTU configuration when logical
channel framing is using an OTU protocol, e.g., OTU1, OTU3,
etc.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'otn'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'otn']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config (container)

    YANG Description: Configuration data for OTN protocol framing
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for OTN protocol framing
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state (container)

    YANG Description: Operational state data for OTN protocol PMs, statistics,
etc.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for OTN protocol PMs, statistics,
etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for Ethernet protocol framing on
logical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__client_als','__als_delay',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__als_delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="als-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)
    self.__client_als = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ETHERNET': {}, u'NONE': {}, u'LASER_SHUTDOWN': {}},), default=six.text_type("ETHERNET"), is_leaf=True, yang_name="client-als", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'ethernet', u'config']

  def _get_client_als(self):
    """
    Getter method for client_als, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/config/client_als (enumeration)

    YANG Description: Sets the client port behavior that defines if the actions
of automatic laser shutdown (als), ethernet fault
propagation, or nothing will be done upon the detection
of a failure on the line port or the upstream remote
client port.
    """
    return self.__client_als
      
  def _set_client_als(self, v, load=False):
    """
    Setter method for client_als, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/config/client_als (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client_als is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client_als() directly.

    YANG Description: Sets the client port behavior that defines if the actions
of automatic laser shutdown (als), ethernet fault
propagation, or nothing will be done upon the detection
of a failure on the line port or the upstream remote
client port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ETHERNET': {}, u'NONE': {}, u'LASER_SHUTDOWN': {}},), default=six.text_type("ETHERNET"), is_leaf=True, yang_name="client-als", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client_als must be of a type compatible with enumeration""",
          'defined-type': "openconfig-terminal-device:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ETHERNET': {}, u'NONE': {}, u'LASER_SHUTDOWN': {}},), default=six.text_type("ETHERNET"), is_leaf=True, yang_name="client-als", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=True)""",
        })

    self.__client_als = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client_als(self):
    self.__client_als = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ETHERNET': {}, u'NONE': {}, u'LASER_SHUTDOWN': {}},), default=six.text_type("ETHERNET"), is_leaf=True, yang_name="client-als", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=True)


  def _get_als_delay(self):
    """
    Getter method for als_delay, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/config/als_delay (uint32)

    YANG Description: The timer to delay the client-als actions on the client
port when a local or remote fault is detected on the line
port. The delay will only be valid when the client-als is
set to LASER_SHUTDOWN
    """
    return self.__als_delay
      
  def _set_als_delay(self, v, load=False):
    """
    Setter method for als_delay, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/config/als_delay (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_als_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_als_delay() directly.

    YANG Description: The timer to delay the client-als actions on the client
port when a local or remote fault is detected on the line
port. The delay will only be valid when the client-als is
set to LASER_SHUTDOWN
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="als-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """als_delay must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="als-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)""",
        })

    self.__als_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_als_delay(self):
    self.__als_delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="als-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)

  client_als = __builtin__.property(_get_client_als, _set_client_als)
  als_delay = __builtin__.property(_get_als_delay, _set_als_delay)


  _pyangbind_elements = OrderedDict([('client_als', client_als), ('als_delay', als_delay), ])


class yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for Ethernet protocol framing
on logical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__client_als','__als_delay','__in_mac_control_frames','__in_mac_pause_frames','__in_oversize_frames','__in_undersize_frames','__in_jabber_frames','__in_fragment_frames','__in_8021q_frames','__in_crc_errors','__in_block_errors','__out_mac_control_frames','__out_mac_pause_frames','__out_8021q_frames','__in_pcs_bip_errors','__in_pcs_errored_seconds','__in_pcs_severely_errored_seconds','__in_pcs_unavailable_seconds','__out_pcs_bip_errors','__out_crc_errors','__out_block_errors',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__in_oversize_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-oversize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_block_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_pcs_errored_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_pcs_severely_errored_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-severely-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__out_crc_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_undersize_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-undersize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__out_mac_control_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_mac_pause_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_jabber_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-jabber-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_pcs_bip_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-bip-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_8021q_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_fragment_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fragment-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__out_block_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__out_pcs_bip_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pcs-bip-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__als_delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="als-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    self.__client_als = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ETHERNET': {}, u'NONE': {}, u'LASER_SHUTDOWN': {}},), default=six.text_type("ETHERNET"), is_leaf=True, yang_name="client-als", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)
    self.__in_mac_control_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_pcs_unavailable_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-unavailable-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__out_8021q_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__out_mac_pause_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_crc_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'ethernet', u'state']

  def _get_client_als(self):
    """
    Getter method for client_als, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/client_als (enumeration)

    YANG Description: Sets the client port behavior that defines if the actions
of automatic laser shutdown (als), ethernet fault
propagation, or nothing will be done upon the detection
of a failure on the line port or the upstream remote
client port.
    """
    return self.__client_als
      
  def _set_client_als(self, v, load=False):
    """
    Setter method for client_als, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/client_als (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client_als is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client_als() directly.

    YANG Description: Sets the client port behavior that defines if the actions
of automatic laser shutdown (als), ethernet fault
propagation, or nothing will be done upon the detection
of a failure on the line port or the upstream remote
client port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ETHERNET': {}, u'NONE': {}, u'LASER_SHUTDOWN': {}},), default=six.text_type("ETHERNET"), is_leaf=True, yang_name="client-als", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client_als must be of a type compatible with enumeration""",
          'defined-type': "openconfig-terminal-device:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ETHERNET': {}, u'NONE': {}, u'LASER_SHUTDOWN': {}},), default=six.text_type("ETHERNET"), is_leaf=True, yang_name="client-als", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)""",
        })

    self.__client_als = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client_als(self):
    self.__client_als = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'ETHERNET': {}, u'NONE': {}, u'LASER_SHUTDOWN': {}},), default=six.text_type("ETHERNET"), is_leaf=True, yang_name="client-als", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)


  def _get_als_delay(self):
    """
    Getter method for als_delay, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/als_delay (uint32)

    YANG Description: The timer to delay the client-als actions on the client
port when a local or remote fault is detected on the line
port. The delay will only be valid when the client-als is
set to LASER_SHUTDOWN
    """
    return self.__als_delay
      
  def _set_als_delay(self, v, load=False):
    """
    Setter method for als_delay, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/als_delay (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_als_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_als_delay() directly.

    YANG Description: The timer to delay the client-als actions on the client
port when a local or remote fault is detected on the line
port. The delay will only be valid when the client-als is
set to LASER_SHUTDOWN
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="als-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """als_delay must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="als-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)""",
        })

    self.__als_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_als_delay(self):
    self.__als_delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="als-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)


  def _get_in_mac_control_frames(self):
    """
    Getter method for in_mac_control_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_mac_control_frames (oc-yang:counter64)

    YANG Description: MAC layer control frames received on the interface
    """
    return self.__in_mac_control_frames
      
  def _set_in_mac_control_frames(self, v, load=False):
    """
    Setter method for in_mac_control_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_mac_control_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_mac_control_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_mac_control_frames() directly.

    YANG Description: MAC layer control frames received on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_mac_control_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_mac_control_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_mac_control_frames(self):
    self.__in_mac_control_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_mac_pause_frames(self):
    """
    Getter method for in_mac_pause_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_mac_pause_frames (oc-yang:counter64)

    YANG Description: MAC layer PAUSE frames received on the interface
    """
    return self.__in_mac_pause_frames
      
  def _set_in_mac_pause_frames(self, v, load=False):
    """
    Setter method for in_mac_pause_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_mac_pause_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_mac_pause_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_mac_pause_frames() directly.

    YANG Description: MAC layer PAUSE frames received on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_mac_pause_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_mac_pause_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_mac_pause_frames(self):
    self.__in_mac_pause_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_oversize_frames(self):
    """
    Getter method for in_oversize_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_oversize_frames (oc-yang:counter64)

    YANG Description: The total number of frames received that were
longer than 1518 octets (excluding framing bits,
but including FCS octets) and were otherwise
well formed.
    """
    return self.__in_oversize_frames
      
  def _set_in_oversize_frames(self, v, load=False):
    """
    Setter method for in_oversize_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_oversize_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_oversize_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_oversize_frames() directly.

    YANG Description: The total number of frames received that were
longer than 1518 octets (excluding framing bits,
but including FCS octets) and were otherwise
well formed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-oversize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_oversize_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-oversize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_oversize_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_oversize_frames(self):
    self.__in_oversize_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-oversize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_undersize_frames(self):
    """
    Getter method for in_undersize_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_undersize_frames (oc-yang:counter64)

    YANG Description: The total number of frames received that were
less than 64 octets long (excluding framing bits,
but including FCS octets) and were otherwise well
formed.
    """
    return self.__in_undersize_frames
      
  def _set_in_undersize_frames(self, v, load=False):
    """
    Setter method for in_undersize_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_undersize_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_undersize_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_undersize_frames() directly.

    YANG Description: The total number of frames received that were
less than 64 octets long (excluding framing bits,
but including FCS octets) and were otherwise well
formed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-undersize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_undersize_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-undersize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_undersize_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_undersize_frames(self):
    self.__in_undersize_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-undersize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_jabber_frames(self):
    """
    Getter method for in_jabber_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_jabber_frames (oc-yang:counter64)

    YANG Description: Number of jabber frames received on the
interface.  Jabber frames are typically defined as oversize
frames which also have a bad CRC.  Implementations may use
slightly different definitions of what constitutes a jabber
frame.  Often indicative of a NIC hardware problem.
    """
    return self.__in_jabber_frames
      
  def _set_in_jabber_frames(self, v, load=False):
    """
    Setter method for in_jabber_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_jabber_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_jabber_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_jabber_frames() directly.

    YANG Description: Number of jabber frames received on the
interface.  Jabber frames are typically defined as oversize
frames which also have a bad CRC.  Implementations may use
slightly different definitions of what constitutes a jabber
frame.  Often indicative of a NIC hardware problem.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-jabber-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_jabber_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-jabber-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_jabber_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_jabber_frames(self):
    self.__in_jabber_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-jabber-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_fragment_frames(self):
    """
    Getter method for in_fragment_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_fragment_frames (oc-yang:counter64)

    YANG Description: The total number of frames received that were less than
64 octets in length (excluding framing bits but including
FCS octets) and had either a bad Frame Check Sequence
(FCS) with an integral number of octets (FCS Error) or a
bad FCS with a non-integral number of octets (Alignment
Error).
    """
    return self.__in_fragment_frames
      
  def _set_in_fragment_frames(self, v, load=False):
    """
    Setter method for in_fragment_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_fragment_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_fragment_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_fragment_frames() directly.

    YANG Description: The total number of frames received that were less than
64 octets in length (excluding framing bits but including
FCS octets) and had either a bad Frame Check Sequence
(FCS) with an integral number of octets (FCS Error) or a
bad FCS with a non-integral number of octets (Alignment
Error).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fragment-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_fragment_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fragment-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_fragment_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_fragment_frames(self):
    self.__in_fragment_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fragment-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_8021q_frames(self):
    """
    Getter method for in_8021q_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_8021q_frames (oc-yang:counter64)

    YANG Description: Number of 802.1q tagged frames received on the interface
    """
    return self.__in_8021q_frames
      
  def _set_in_8021q_frames(self, v, load=False):
    """
    Setter method for in_8021q_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_8021q_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_8021q_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_8021q_frames() directly.

    YANG Description: Number of 802.1q tagged frames received on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_8021q_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_8021q_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_8021q_frames(self):
    self.__in_8021q_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_crc_errors(self):
    """
    Getter method for in_crc_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_crc_errors (oc-yang:counter64)

    YANG Description: The total number of frames received that
had a length (excluding framing bits, but
including FCS octets) of between 64 and 1518
octets, inclusive, but had either a bad
Frame Check Sequence (FCS) with an integral
number of octets (FCS Error) or a bad FCS with
a non-integral number of octets (Alignment Error)
    """
    return self.__in_crc_errors
      
  def _set_in_crc_errors(self, v, load=False):
    """
    Setter method for in_crc_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_crc_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_crc_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_crc_errors() directly.

    YANG Description: The total number of frames received that
had a length (excluding framing bits, but
including FCS octets) of between 64 and 1518
octets, inclusive, but had either a bad
Frame Check Sequence (FCS) with an integral
number of octets (FCS Error) or a bad FCS with
a non-integral number of octets (Alignment Error)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_crc_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_crc_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_crc_errors(self):
    self.__in_crc_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_block_errors(self):
    """
    Getter method for in_block_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_block_errors (oc-yang:counter64)

    YANG Description: The number of received errored blocks. Error detection codes
are capable of detecting whether one or more errors have
occurred in a given sequence of bits – the block. It is
normally not possible to determine the exact number of errored
bits within the block
    """
    return self.__in_block_errors
      
  def _set_in_block_errors(self, v, load=False):
    """
    Setter method for in_block_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_block_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_block_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_block_errors() directly.

    YANG Description: The number of received errored blocks. Error detection codes
are capable of detecting whether one or more errors have
occurred in a given sequence of bits – the block. It is
normally not possible to determine the exact number of errored
bits within the block
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_block_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_block_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_block_errors(self):
    self.__in_block_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_mac_control_frames(self):
    """
    Getter method for out_mac_control_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_mac_control_frames (oc-yang:counter64)

    YANG Description: MAC layer control frames sent on the interface
    """
    return self.__out_mac_control_frames
      
  def _set_out_mac_control_frames(self, v, load=False):
    """
    Setter method for out_mac_control_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_mac_control_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_mac_control_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_mac_control_frames() directly.

    YANG Description: MAC layer control frames sent on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_mac_control_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_mac_control_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_mac_control_frames(self):
    self.__out_mac_control_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_mac_pause_frames(self):
    """
    Getter method for out_mac_pause_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_mac_pause_frames (oc-yang:counter64)

    YANG Description: MAC layer PAUSE frames sent on the interface
    """
    return self.__out_mac_pause_frames
      
  def _set_out_mac_pause_frames(self, v, load=False):
    """
    Setter method for out_mac_pause_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_mac_pause_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_mac_pause_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_mac_pause_frames() directly.

    YANG Description: MAC layer PAUSE frames sent on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_mac_pause_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_mac_pause_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_mac_pause_frames(self):
    self.__out_mac_pause_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_8021q_frames(self):
    """
    Getter method for out_8021q_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_8021q_frames (oc-yang:counter64)

    YANG Description: Number of 802.1q tagged frames sent on the interface
    """
    return self.__out_8021q_frames
      
  def _set_out_8021q_frames(self, v, load=False):
    """
    Setter method for out_8021q_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_8021q_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_8021q_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_8021q_frames() directly.

    YANG Description: Number of 802.1q tagged frames sent on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_8021q_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_8021q_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_8021q_frames(self):
    self.__out_8021q_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_pcs_bip_errors(self):
    """
    Getter method for in_pcs_bip_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_pcs_bip_errors (oc-yang:counter64)

    YANG Description: The number of received bit interleaved parity (BIP) errors
at the physical coding sublayer (PCS). If the interface
consists of multiple lanes, this will be the sum of all
errors on the lane
    """
    return self.__in_pcs_bip_errors
      
  def _set_in_pcs_bip_errors(self, v, load=False):
    """
    Setter method for in_pcs_bip_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_pcs_bip_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_pcs_bip_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_pcs_bip_errors() directly.

    YANG Description: The number of received bit interleaved parity (BIP) errors
at the physical coding sublayer (PCS). If the interface
consists of multiple lanes, this will be the sum of all
errors on the lane
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-bip-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_pcs_bip_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-bip-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_pcs_bip_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_pcs_bip_errors(self):
    self.__in_pcs_bip_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-bip-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_pcs_errored_seconds(self):
    """
    Getter method for in_pcs_errored_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_pcs_errored_seconds (oc-yang:counter64)

    YANG Description: The number of seconds that physical coding sublayer (PCS)
errors have crossed a sytem defined threshold indicating the
link is erroring
    """
    return self.__in_pcs_errored_seconds
      
  def _set_in_pcs_errored_seconds(self, v, load=False):
    """
    Setter method for in_pcs_errored_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_pcs_errored_seconds (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_pcs_errored_seconds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_pcs_errored_seconds() directly.

    YANG Description: The number of seconds that physical coding sublayer (PCS)
errors have crossed a sytem defined threshold indicating the
link is erroring
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_pcs_errored_seconds must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_pcs_errored_seconds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_pcs_errored_seconds(self):
    self.__in_pcs_errored_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_pcs_severely_errored_seconds(self):
    """
    Getter method for in_pcs_severely_errored_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_pcs_severely_errored_seconds (oc-yang:counter64)

    YANG Description: The number of seconds that physical coding sublayer (PCS)
errors have crossed a system defined threshold indicating the
link is severely erroring
    """
    return self.__in_pcs_severely_errored_seconds
      
  def _set_in_pcs_severely_errored_seconds(self, v, load=False):
    """
    Setter method for in_pcs_severely_errored_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_pcs_severely_errored_seconds (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_pcs_severely_errored_seconds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_pcs_severely_errored_seconds() directly.

    YANG Description: The number of seconds that physical coding sublayer (PCS)
errors have crossed a system defined threshold indicating the
link is severely erroring
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-severely-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_pcs_severely_errored_seconds must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-severely-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_pcs_severely_errored_seconds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_pcs_severely_errored_seconds(self):
    self.__in_pcs_severely_errored_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-severely-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_pcs_unavailable_seconds(self):
    """
    Getter method for in_pcs_unavailable_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_pcs_unavailable_seconds (oc-yang:counter64)

    YANG Description: The number of seconds that physical coding sublayer (PCS)
errors have crossed a system defined threshold indicating the
link is unavailable
    """
    return self.__in_pcs_unavailable_seconds
      
  def _set_in_pcs_unavailable_seconds(self, v, load=False):
    """
    Setter method for in_pcs_unavailable_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_pcs_unavailable_seconds (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_pcs_unavailable_seconds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_pcs_unavailable_seconds() directly.

    YANG Description: The number of seconds that physical coding sublayer (PCS)
errors have crossed a system defined threshold indicating the
link is unavailable
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-unavailable-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_pcs_unavailable_seconds must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-unavailable-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_pcs_unavailable_seconds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_pcs_unavailable_seconds(self):
    self.__in_pcs_unavailable_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-pcs-unavailable-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_pcs_bip_errors(self):
    """
    Getter method for out_pcs_bip_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_pcs_bip_errors (oc-yang:counter64)

    YANG Description: The number of transmitted bit interleaved parity (BIP) errors
at the physical coding sublayer (PCS). If the interface
consists of multiple lanes, this will be the sum of all
errors on the lane
    """
    return self.__out_pcs_bip_errors
      
  def _set_out_pcs_bip_errors(self, v, load=False):
    """
    Setter method for out_pcs_bip_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_pcs_bip_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_pcs_bip_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_pcs_bip_errors() directly.

    YANG Description: The number of transmitted bit interleaved parity (BIP) errors
at the physical coding sublayer (PCS). If the interface
consists of multiple lanes, this will be the sum of all
errors on the lane
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pcs-bip-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_pcs_bip_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pcs-bip-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_pcs_bip_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_pcs_bip_errors(self):
    self.__out_pcs_bip_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-pcs-bip-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_crc_errors(self):
    """
    Getter method for out_crc_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_crc_errors (oc-yang:counter64)

    YANG Description: Number of FCS/CRC error check failures sent on the interface
    """
    return self.__out_crc_errors
      
  def _set_out_crc_errors(self, v, load=False):
    """
    Setter method for out_crc_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_crc_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_crc_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_crc_errors() directly.

    YANG Description: Number of FCS/CRC error check failures sent on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_crc_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_crc_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_crc_errors(self):
    self.__out_crc_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_block_errors(self):
    """
    Getter method for out_block_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_block_errors (oc-yang:counter64)

    YANG Description: The number of transmitted errored blocks. Error detection
codes are capable of detecting whether one or more errors have
occurred in a given sequence of bits – the block. It is
normally not possible to determine the exact number of errored
bits within the block
    """
    return self.__out_block_errors
      
  def _set_out_block_errors(self, v, load=False):
    """
    Setter method for out_block_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_block_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_block_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_block_errors() directly.

    YANG Description: The number of transmitted errored blocks. Error detection
codes are capable of detecting whether one or more errors have
occurred in a given sequence of bits – the block. It is
normally not possible to determine the exact number of errored
bits within the block
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_block_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_block_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_block_errors(self):
    self.__out_block_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)

  client_als = __builtin__.property(_get_client_als)
  als_delay = __builtin__.property(_get_als_delay)
  in_mac_control_frames = __builtin__.property(_get_in_mac_control_frames)
  in_mac_pause_frames = __builtin__.property(_get_in_mac_pause_frames)
  in_oversize_frames = __builtin__.property(_get_in_oversize_frames)
  in_undersize_frames = __builtin__.property(_get_in_undersize_frames)
  in_jabber_frames = __builtin__.property(_get_in_jabber_frames)
  in_fragment_frames = __builtin__.property(_get_in_fragment_frames)
  in_8021q_frames = __builtin__.property(_get_in_8021q_frames)
  in_crc_errors = __builtin__.property(_get_in_crc_errors)
  in_block_errors = __builtin__.property(_get_in_block_errors)
  out_mac_control_frames = __builtin__.property(_get_out_mac_control_frames)
  out_mac_pause_frames = __builtin__.property(_get_out_mac_pause_frames)
  out_8021q_frames = __builtin__.property(_get_out_8021q_frames)
  in_pcs_bip_errors = __builtin__.property(_get_in_pcs_bip_errors)
  in_pcs_errored_seconds = __builtin__.property(_get_in_pcs_errored_seconds)
  in_pcs_severely_errored_seconds = __builtin__.property(_get_in_pcs_severely_errored_seconds)
  in_pcs_unavailable_seconds = __builtin__.property(_get_in_pcs_unavailable_seconds)
  out_pcs_bip_errors = __builtin__.property(_get_out_pcs_bip_errors)
  out_crc_errors = __builtin__.property(_get_out_crc_errors)
  out_block_errors = __builtin__.property(_get_out_block_errors)


  _pyangbind_elements = OrderedDict([('client_als', client_als), ('als_delay', als_delay), ('in_mac_control_frames', in_mac_control_frames), ('in_mac_pause_frames', in_mac_pause_frames), ('in_oversize_frames', in_oversize_frames), ('in_undersize_frames', in_undersize_frames), ('in_jabber_frames', in_jabber_frames), ('in_fragment_frames', in_fragment_frames), ('in_8021q_frames', in_8021q_frames), ('in_crc_errors', in_crc_errors), ('in_block_errors', in_block_errors), ('out_mac_control_frames', out_mac_control_frames), ('out_mac_pause_frames', out_mac_pause_frames), ('out_8021q_frames', out_8021q_frames), ('in_pcs_bip_errors', in_pcs_bip_errors), ('in_pcs_errored_seconds', in_pcs_errored_seconds), ('in_pcs_severely_errored_seconds', in_pcs_severely_errored_seconds), ('in_pcs_unavailable_seconds', in_pcs_unavailable_seconds), ('out_pcs_bip_errors', out_pcs_bip_errors), ('out_crc_errors', out_crc_errors), ('out_block_errors', out_block_errors), ])


class yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/lldp/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: LLDP configuration data for logical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__snooping',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)
    self.__snooping = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="snooping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'ethernet', u'lldp', u'config']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/config/enabled (boolean)

    YANG Description: Enable or disable the LLDP protocol on the logical channel.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Enable or disable the LLDP protocol on the logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)


  def _get_snooping(self):
    """
    Getter method for snooping, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/config/snooping (boolean)

    YANG Description: If true, LLDP PDUs are only received and processed on
the logical-channel, but are not originated by the local
agent. The PDUs are not dropped by the logical channel after
processing, but relayed to the downstream link layer
neighbors. The snooping mode is valid only when LLDP is
enabled on the logical channel. The snooping mode is useful
when a logical channel does not want its link layer neighbors
to discover itself since, for example, it is a lower-layer
logical channel.
    """
    return self.__snooping
      
  def _set_snooping(self, v, load=False):
    """
    Setter method for snooping, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/config/snooping (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_snooping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_snooping() directly.

    YANG Description: If true, LLDP PDUs are only received and processed on
the logical-channel, but are not originated by the local
agent. The PDUs are not dropped by the logical channel after
processing, but relayed to the downstream link layer
neighbors. The snooping mode is valid only when LLDP is
enabled on the logical channel. The snooping mode is useful
when a logical channel does not want its link layer neighbors
to discover itself since, for example, it is a lower-layer
logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="snooping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """snooping must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="snooping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)""",
        })

    self.__snooping = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_snooping(self):
    self.__snooping = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="snooping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  snooping = __builtin__.property(_get_snooping, _set_snooping)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('snooping', snooping), ])


class yc_counters_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_state_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/lldp/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: LLDP counters on each interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__frame_in','__frame_out','__frame_error_in','__frame_discard','__tlv_discard','__tlv_unknown','__last_clear','__frame_error_out',)

  _yang_name = 'counters'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__frame_error_out = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-error-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__last_clear = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:date-and-time', is_config=False)
    self.__frame_out = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__frame_error_in = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-error-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__tlv_unknown = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tlv-unknown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__tlv_discard = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tlv-discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__frame_in = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__frame_discard = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'ethernet', u'lldp', u'state', u'counters']

  def _get_frame_in(self):
    """
    Getter method for frame_in, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/frame_in (yang:counter64)

    YANG Description: The number of lldp frames received.
    """
    return self.__frame_in
      
  def _set_frame_in(self, v, load=False):
    """
    Setter method for frame_in, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/frame_in (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frame_in is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frame_in() directly.

    YANG Description: The number of lldp frames received.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frame_in must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__frame_in = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frame_in(self):
    self.__frame_in = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_frame_out(self):
    """
    Getter method for frame_out, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/frame_out (yang:counter64)

    YANG Description: The number of frames transmitted out.
    """
    return self.__frame_out
      
  def _set_frame_out(self, v, load=False):
    """
    Setter method for frame_out, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/frame_out (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frame_out is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frame_out() directly.

    YANG Description: The number of frames transmitted out.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frame_out must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__frame_out = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frame_out(self):
    self.__frame_out = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_frame_error_in(self):
    """
    Getter method for frame_error_in, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/frame_error_in (yang:counter64)

    YANG Description: The number of LLDP frames received with errors.
    """
    return self.__frame_error_in
      
  def _set_frame_error_in(self, v, load=False):
    """
    Setter method for frame_error_in, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/frame_error_in (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frame_error_in is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frame_error_in() directly.

    YANG Description: The number of LLDP frames received with errors.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-error-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frame_error_in must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-error-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__frame_error_in = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frame_error_in(self):
    self.__frame_error_in = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-error-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_frame_discard(self):
    """
    Getter method for frame_discard, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/frame_discard (yang:counter64)

    YANG Description: The number of LLDP frames received and discarded.
    """
    return self.__frame_discard
      
  def _set_frame_discard(self, v, load=False):
    """
    Setter method for frame_discard, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/frame_discard (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frame_discard is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frame_discard() directly.

    YANG Description: The number of LLDP frames received and discarded.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frame_discard must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__frame_discard = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frame_discard(self):
    self.__frame_discard = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_tlv_discard(self):
    """
    Getter method for tlv_discard, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/tlv_discard (yang:counter64)

    YANG Description: The number of TLV frames received and discarded.
    """
    return self.__tlv_discard
      
  def _set_tlv_discard(self, v, load=False):
    """
    Setter method for tlv_discard, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/tlv_discard (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tlv_discard is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tlv_discard() directly.

    YANG Description: The number of TLV frames received and discarded.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tlv-discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tlv_discard must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tlv-discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__tlv_discard = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tlv_discard(self):
    self.__tlv_discard = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tlv-discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_tlv_unknown(self):
    """
    Getter method for tlv_unknown, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/tlv_unknown (yang:counter64)

    YANG Description: The number of frames received with unknown TLV.
    """
    return self.__tlv_unknown
      
  def _set_tlv_unknown(self, v, load=False):
    """
    Setter method for tlv_unknown, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/tlv_unknown (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tlv_unknown is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tlv_unknown() directly.

    YANG Description: The number of frames received with unknown TLV.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tlv-unknown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tlv_unknown must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tlv-unknown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__tlv_unknown = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tlv_unknown(self):
    self.__tlv_unknown = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tlv-unknown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_last_clear(self):
    """
    Getter method for last_clear, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/last_clear (yang:date-and-time)

    YANG Description: Indicates the last time the counters were
cleared.
    """
    return self.__last_clear
      
  def _set_last_clear(self, v, load=False):
    """
    Setter method for last_clear, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/last_clear (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_clear is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_clear() directly.

    YANG Description: Indicates the last time the counters were
cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_clear must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__last_clear = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_clear(self):
    self.__last_clear = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="last-clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:date-and-time', is_config=False)


  def _get_frame_error_out(self):
    """
    Getter method for frame_error_out, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/frame_error_out (yang:counter64)

    YANG Description: The number of frame transmit errors on the
interface.
    """
    return self.__frame_error_out
      
  def _set_frame_error_out(self, v, load=False):
    """
    Setter method for frame_error_out, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters/frame_error_out (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frame_error_out is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frame_error_out() directly.

    YANG Description: The number of frame transmit errors on the
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-error-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frame_error_out must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-error-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__frame_error_out = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frame_error_out(self):
    self.__frame_error_out = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frame-error-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)

  frame_in = __builtin__.property(_get_frame_in)
  frame_out = __builtin__.property(_get_frame_out)
  frame_error_in = __builtin__.property(_get_frame_error_in)
  frame_discard = __builtin__.property(_get_frame_discard)
  tlv_discard = __builtin__.property(_get_tlv_discard)
  tlv_unknown = __builtin__.property(_get_tlv_unknown)
  last_clear = __builtin__.property(_get_last_clear)
  frame_error_out = __builtin__.property(_get_frame_error_out)


  _pyangbind_elements = OrderedDict([('frame_in', frame_in), ('frame_out', frame_out), ('frame_error_in', frame_error_in), ('frame_discard', frame_discard), ('tlv_discard', tlv_discard), ('tlv_unknown', tlv_unknown), ('last_clear', last_clear), ('frame_error_out', frame_error_out), ])


class yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/lldp/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: LLDP operational state data for logical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__snooping','__counters',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)
    self.__snooping = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="snooping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)
    self.__counters = YANGDynClass(base=yc_counters_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'ethernet', u'lldp', u'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/enabled (boolean)

    YANG Description: Enable or disable the LLDP protocol on the logical channel.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Enable or disable the LLDP protocol on the logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)


  def _get_snooping(self):
    """
    Getter method for snooping, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/snooping (boolean)

    YANG Description: If true, LLDP PDUs are only received and processed on
the logical-channel, but are not originated by the local
agent. The PDUs are not dropped by the logical channel after
processing, but relayed to the downstream link layer
neighbors. The snooping mode is valid only when LLDP is
enabled on the logical channel. The snooping mode is useful
when a logical channel does not want its link layer neighbors
to discover itself since, for example, it is a lower-layer
logical channel.
    """
    return self.__snooping
      
  def _set_snooping(self, v, load=False):
    """
    Setter method for snooping, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/snooping (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_snooping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_snooping() directly.

    YANG Description: If true, LLDP PDUs are only received and processed on
the logical-channel, but are not originated by the local
agent. The PDUs are not dropped by the logical channel after
processing, but relayed to the downstream link layer
neighbors. The snooping mode is valid only when LLDP is
enabled on the logical channel. The snooping mode is useful
when a logical channel does not want its link layer neighbors
to discover itself since, for example, it is a lower-layer
logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="snooping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """snooping must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="snooping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)""",
        })

    self.__snooping = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_snooping(self):
    self.__snooping = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="snooping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters (container)

    YANG Description: LLDP counters on each interface
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: LLDP counters on each interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_counters_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_counters_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=yc_counters_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  snooping = __builtin__.property(_get_snooping)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('snooping', snooping), ('counters', counters), ])


class yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/lldp/neighbors/neighbor/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data 
  """
  __slots__ = ('_path_helper', '_extmethods', '__system_name','__system_description','__chassis_id','__chassis_id_type','__id','__age','__last_update','__ttl','__port_id','__port_id_type','__port_description','__management_address','__management_address_type',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__system_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'0..255']}), is_leaf=True, yang_name="system-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__port_id_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PORT_COMPONENT': {}, u'NETWORK_ADDRESS': {}, u'AGENT_CIRCUIT_ID': {}, u'MAC_ADDRESS': {}, u'INTERFACE_NAME': {}, u'LOCAL': {}, u'INTERFACE_ALIAS': {}},), is_leaf=True, yang_name="port-id-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-lldp-types:port-id-type', is_config=False)
    self.__system_description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'0..255']}), is_leaf=True, yang_name="system-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__age = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="age", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint64', is_config=False)
    self.__management_address_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="management-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__port_description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__chassis_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="chassis-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__last_update = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="last-update", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int64', is_config=False)
    self.__chassis_id_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PORT_COMPONENT': {}, u'NETWORK_ADDRESS': {}, u'CHASSIS_COMPONENT': {}, u'MAC_ADDRESS': {}, u'INTERFACE_NAME': {}, u'LOCAL': {}, u'INTERFACE_ALIAS': {}},), is_leaf=True, yang_name="chassis-id-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-lldp-types:chassis-id-type', is_config=False)
    self.__management_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="management-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)
    self.__port_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'ethernet', u'lldp', u'neighbors', u'neighbor', u'state']

  def _get_system_name(self):
    """
    Getter method for system_name, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/system_name (string)

    YANG Description: The system name field shall contain an alpha-numeric string
that indicates the system's administratively assigned name.
The system name should be the system's fully qualified domain
name. If implementations support IETF RFC 3418, the sysName
object should be used for this field.
    """
    return self.__system_name
      
  def _set_system_name(self, v, load=False):
    """
    Setter method for system_name, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/system_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_name() directly.

    YANG Description: The system name field shall contain an alpha-numeric string
that indicates the system's administratively assigned name.
The system name should be the system's fully qualified domain
name. If implementations support IETF RFC 3418, the sysName
object should be used for this field.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'0..255']}), is_leaf=True, yang_name="system-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'0..255']}), is_leaf=True, yang_name="system-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__system_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_name(self):
    self.__system_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'0..255']}), is_leaf=True, yang_name="system-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_system_description(self):
    """
    Getter method for system_description, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/system_description (string)

    YANG Description: The system description field shall contain an alpha-numeric
string that is the textual description of the network entity.
The system description should include the full name and
version identification of the system's hardware type,
software operating system, and networking software. If
implementations support IETF RFC 3418, the sysDescr object
should be used for this field.
    """
    return self.__system_description
      
  def _set_system_description(self, v, load=False):
    """
    Setter method for system_description, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/system_description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_description() directly.

    YANG Description: The system description field shall contain an alpha-numeric
string that is the textual description of the network entity.
The system description should include the full name and
version identification of the system's hardware type,
software operating system, and networking software. If
implementations support IETF RFC 3418, the sysDescr object
should be used for this field.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'0..255']}), is_leaf=True, yang_name="system-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'0..255']}), is_leaf=True, yang_name="system-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__system_description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_description(self):
    self.__system_description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'length': [u'0..255']}), is_leaf=True, yang_name="system-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_chassis_id(self):
    """
    Getter method for chassis_id, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/chassis_id (string)

    YANG Description: The Chassis ID is a mandatory TLV which identifies the
chassis component of the endpoint identifier associated with
the transmitting LLDP agent
    """
    return self.__chassis_id
      
  def _set_chassis_id(self, v, load=False):
    """
    Setter method for chassis_id, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/chassis_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_chassis_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_chassis_id() directly.

    YANG Description: The Chassis ID is a mandatory TLV which identifies the
chassis component of the endpoint identifier associated with
the transmitting LLDP agent
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="chassis-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """chassis_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="chassis-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__chassis_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_chassis_id(self):
    self.__chassis_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="chassis-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_chassis_id_type(self):
    """
    Getter method for chassis_id_type, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/chassis_id_type (oc-lldp-types:chassis-id-type)

    YANG Description: This field identifies the format and source of the chassis
identifier string. It is an enumerator defined by the
LldpChassisIdSubtype object from IEEE 802.1AB MIB.
    """
    return self.__chassis_id_type
      
  def _set_chassis_id_type(self, v, load=False):
    """
    Setter method for chassis_id_type, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/chassis_id_type (oc-lldp-types:chassis-id-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_chassis_id_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_chassis_id_type() directly.

    YANG Description: This field identifies the format and source of the chassis
identifier string. It is an enumerator defined by the
LldpChassisIdSubtype object from IEEE 802.1AB MIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PORT_COMPONENT': {}, u'NETWORK_ADDRESS': {}, u'CHASSIS_COMPONENT': {}, u'MAC_ADDRESS': {}, u'INTERFACE_NAME': {}, u'LOCAL': {}, u'INTERFACE_ALIAS': {}},), is_leaf=True, yang_name="chassis-id-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-lldp-types:chassis-id-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """chassis_id_type must be of a type compatible with oc-lldp-types:chassis-id-type""",
          'defined-type': "oc-lldp-types:chassis-id-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PORT_COMPONENT': {}, u'NETWORK_ADDRESS': {}, u'CHASSIS_COMPONENT': {}, u'MAC_ADDRESS': {}, u'INTERFACE_NAME': {}, u'LOCAL': {}, u'INTERFACE_ALIAS': {}},), is_leaf=True, yang_name="chassis-id-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-lldp-types:chassis-id-type', is_config=False)""",
        })

    self.__chassis_id_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_chassis_id_type(self):
    self.__chassis_id_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PORT_COMPONENT': {}, u'NETWORK_ADDRESS': {}, u'CHASSIS_COMPONENT': {}, u'MAC_ADDRESS': {}, u'INTERFACE_NAME': {}, u'LOCAL': {}, u'INTERFACE_ALIAS': {}},), is_leaf=True, yang_name="chassis-id-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-lldp-types:chassis-id-type', is_config=False)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/id (string)

    YANG Description: System generated identifier for the neighbor on the
interface.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: System generated identifier for the neighbor on the
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_age(self):
    """
    Getter method for age, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/age (uint64)

    YANG Description: Age since discovery
    """
    return self.__age
      
  def _set_age(self, v, load=False):
    """
    Setter method for age, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/age (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_age is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_age() directly.

    YANG Description: Age since discovery
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="age", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """age must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="age", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint64', is_config=False)""",
        })

    self.__age = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_age(self):
    self.__age = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="age", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint64', is_config=False)


  def _get_last_update(self):
    """
    Getter method for last_update, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/last_update (int64)

    YANG Description: Seconds since last update received.
    """
    return self.__last_update
      
  def _set_last_update(self, v, load=False):
    """
    Setter method for last_update, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/last_update (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_update is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_update() directly.

    YANG Description: Seconds since last update received.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="last-update", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_update must be of a type compatible with int64""",
          'defined-type': "int64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="last-update", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int64', is_config=False)""",
        })

    self.__last_update = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_update(self):
    self.__last_update = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="last-update", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int64', is_config=False)


  def _get_ttl(self):
    """
    Getter method for ttl, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/ttl (uint16)

    YANG Description: The time-to-live (TTL) is a mandatory TLV which indicates
how long information from the neighbor should be considered
valid.
    """
    return self.__ttl
      
  def _set_ttl(self, v, load=False):
    """
    Setter method for ttl, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/ttl (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ttl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ttl() directly.

    YANG Description: The time-to-live (TTL) is a mandatory TLV which indicates
how long information from the neighbor should be considered
valid.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ttl must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)""",
        })

    self.__ttl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ttl(self):
    self.__ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)


  def _get_port_id(self):
    """
    Getter method for port_id, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/port_id (string)

    YANG Description: The Port ID is a mandatory TLV which identifies the port
component of the endpoint identifier associated with the
transmitting LLDP agent. If the specified port is an IEEE
802.3 Repeater port, then this TLV is optional.
    """
    return self.__port_id
      
  def _set_port_id(self, v, load=False):
    """
    Setter method for port_id, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/port_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_id() directly.

    YANG Description: The Port ID is a mandatory TLV which identifies the port
component of the endpoint identifier associated with the
transmitting LLDP agent. If the specified port is an IEEE
802.3 Repeater port, then this TLV is optional.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="port-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__port_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_id(self):
    self.__port_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_port_id_type(self):
    """
    Getter method for port_id_type, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/port_id_type (oc-lldp-types:port-id-type)

    YANG Description: This field identifies the format and source of the port
identifier string. It is an enumerator defined by the
PtopoPortIdType object from RFC2922.
    """
    return self.__port_id_type
      
  def _set_port_id_type(self, v, load=False):
    """
    Setter method for port_id_type, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/port_id_type (oc-lldp-types:port-id-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_id_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_id_type() directly.

    YANG Description: This field identifies the format and source of the port
identifier string. It is an enumerator defined by the
PtopoPortIdType object from RFC2922.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PORT_COMPONENT': {}, u'NETWORK_ADDRESS': {}, u'AGENT_CIRCUIT_ID': {}, u'MAC_ADDRESS': {}, u'INTERFACE_NAME': {}, u'LOCAL': {}, u'INTERFACE_ALIAS': {}},), is_leaf=True, yang_name="port-id-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-lldp-types:port-id-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_id_type must be of a type compatible with oc-lldp-types:port-id-type""",
          'defined-type': "oc-lldp-types:port-id-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PORT_COMPONENT': {}, u'NETWORK_ADDRESS': {}, u'AGENT_CIRCUIT_ID': {}, u'MAC_ADDRESS': {}, u'INTERFACE_NAME': {}, u'LOCAL': {}, u'INTERFACE_ALIAS': {}},), is_leaf=True, yang_name="port-id-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-lldp-types:port-id-type', is_config=False)""",
        })

    self.__port_id_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_id_type(self):
    self.__port_id_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PORT_COMPONENT': {}, u'NETWORK_ADDRESS': {}, u'AGENT_CIRCUIT_ID': {}, u'MAC_ADDRESS': {}, u'INTERFACE_NAME': {}, u'LOCAL': {}, u'INTERFACE_ALIAS': {}},), is_leaf=True, yang_name="port-id-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-lldp-types:port-id-type', is_config=False)


  def _get_port_description(self):
    """
    Getter method for port_description, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/port_description (string)

    YANG Description: The binary string containing the actual port identifier for
the port which this LLDP PDU was transmitted. The source and
format of this field is defined by PtopoPortId from
RFC2922.
    """
    return self.__port_description
      
  def _set_port_description(self, v, load=False):
    """
    Setter method for port_description, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/port_description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_description() directly.

    YANG Description: The binary string containing the actual port identifier for
the port which this LLDP PDU was transmitted. The source and
format of this field is defined by PtopoPortId from
RFC2922.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="port-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__port_description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_description(self):
    self.__port_description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_management_address(self):
    """
    Getter method for management_address, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/management_address (string)

    YANG Description: The Management Address is a mandatory TLV which identifies a
network address associated with the local LLDP agent, which
can be used to reach the agent on the port identified in the
Port ID TLV.
    """
    return self.__management_address
      
  def _set_management_address(self, v, load=False):
    """
    Setter method for management_address, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/management_address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_management_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_management_address() directly.

    YANG Description: The Management Address is a mandatory TLV which identifies a
network address associated with the local LLDP agent, which
can be used to reach the agent on the port identified in the
Port ID TLV.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="management-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """management_address must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="management-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__management_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_management_address(self):
    self.__management_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="management-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_management_address_type(self):
    """
    Getter method for management_address_type, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/management_address_type (string)

    YANG Description: The enumerated value for the network address type
identified in this TLV. This enumeration is defined in the
'Assigned Numbers' RFC [RFC3232] and the
ianaAddressFamilyNumbers object.
    """
    return self.__management_address_type
      
  def _set_management_address_type(self, v, load=False):
    """
    Setter method for management_address_type, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state/management_address_type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_management_address_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_management_address_type() directly.

    YANG Description: The enumerated value for the network address type
identified in this TLV. This enumeration is defined in the
'Assigned Numbers' RFC [RFC3232] and the
ianaAddressFamilyNumbers object.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="management-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """management_address_type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="management-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__management_address_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_management_address_type(self):
    self.__management_address_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="management-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)

  system_name = __builtin__.property(_get_system_name)
  system_description = __builtin__.property(_get_system_description)
  chassis_id = __builtin__.property(_get_chassis_id)
  chassis_id_type = __builtin__.property(_get_chassis_id_type)
  id = __builtin__.property(_get_id)
  age = __builtin__.property(_get_age)
  last_update = __builtin__.property(_get_last_update)
  ttl = __builtin__.property(_get_ttl)
  port_id = __builtin__.property(_get_port_id)
  port_id_type = __builtin__.property(_get_port_id_type)
  port_description = __builtin__.property(_get_port_description)
  management_address = __builtin__.property(_get_management_address)
  management_address_type = __builtin__.property(_get_management_address_type)


  _pyangbind_elements = OrderedDict([('system_name', system_name), ('system_description', system_description), ('chassis_id', chassis_id), ('chassis_id_type', chassis_id_type), ('id', id), ('age', age), ('last_update', last_update), ('ttl', ttl), ('port_id', port_id), ('port_id_type', port_id_type), ('port_description', port_description), ('management_address', management_address), ('management_address_type', management_address_type), ])


class yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs_tlv_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/lldp/neighbors/neighbor/custom-tlvs/tlv/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data 
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__oui','__oui_subtype','__value',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__oui_subtype = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui-subtype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__oui = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=False)
    self.__value = YANGDynClass(base=bitarray, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='binary', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'ethernet', u'lldp', u'neighbors', u'neighbor', u'custom-tlvs', u'tlv', u'state']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/state/type (int32)

    YANG Description: The integer value identifying the type of information
contained in the value field.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/state/type (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The integer value identifying the type of information
contained in the value field.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=False)


  def _get_oui(self):
    """
    Getter method for oui, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/state/oui (string)

    YANG Description: The organizationally unique identifier field shall contain
the organization's OUI as defined in Clause 9 of IEEE Std
802. The high-order octet is 0 and the low-order 3 octets
are the SMI Network Management Private Enterprise Code of
the Vendor in network byte order, as defined in the
'Assigned Numbers' RFC [RFC3232].
    """
    return self.__oui
      
  def _set_oui(self, v, load=False):
    """
    Setter method for oui, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/state/oui (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oui is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oui() directly.

    YANG Description: The organizationally unique identifier field shall contain
the organization's OUI as defined in Clause 9 of IEEE Std
802. The high-order octet is 0 and the low-order 3 octets
are the SMI Network Management Private Enterprise Code of
the Vendor in network byte order, as defined in the
'Assigned Numbers' RFC [RFC3232].
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oui must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__oui = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oui(self):
    self.__oui = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_oui_subtype(self):
    """
    Getter method for oui_subtype, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/state/oui_subtype (string)

    YANG Description: The organizationally defined subtype field shall contain a
unique subtype value assigned by the defining organization.
    """
    return self.__oui_subtype
      
  def _set_oui_subtype(self, v, load=False):
    """
    Setter method for oui_subtype, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/state/oui_subtype (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oui_subtype is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oui_subtype() directly.

    YANG Description: The organizationally defined subtype field shall contain a
unique subtype value assigned by the defining organization.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="oui-subtype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oui_subtype must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui-subtype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__oui_subtype = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oui_subtype(self):
    self.__oui_subtype = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui-subtype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/state/value (binary)

    YANG Description: A variable-length octet-string containing the
instance-specific information for this TLV.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/state/value (binary)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: A variable-length octet-string containing the
instance-specific information for this TLV.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=bitarray, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='binary', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with binary""",
          'defined-type': "binary",
          'generated-type': """YANGDynClass(base=bitarray, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='binary', is_config=False)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=bitarray, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='binary', is_config=False)

  type = __builtin__.property(_get_type)
  oui = __builtin__.property(_get_oui)
  oui_subtype = __builtin__.property(_get_oui_subtype)
  value = __builtin__.property(_get_value)


  _pyangbind_elements = OrderedDict([('type', type), ('oui', oui), ('oui_subtype', oui_subtype), ('value', value), ])


class yc_tlv_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs_tlv(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/lldp/neighbors/neighbor/custom-tlvs/tlv. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of custom LLDP TLVs from a neighbor
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__oui','__oui_subtype','__state',)

  _yang_name = 'tlv'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__oui_subtype = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui-subtype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__oui = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs_tlv_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'ethernet', u'lldp', u'neighbors', u'neighbor', u'custom-tlvs', u'tlv']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/type (leafref)

    YANG Description: Reference to type list key
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/type (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Reference to type list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_oui(self):
    """
    Getter method for oui, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/oui (leafref)

    YANG Description: Reference to oui list key
    """
    return self.__oui
      
  def _set_oui(self, v, load=False):
    """
    Setter method for oui, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/oui (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oui is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oui() directly.

    YANG Description: Reference to oui list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oui must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__oui = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oui(self):
    self.__oui = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_oui_subtype(self):
    """
    Getter method for oui_subtype, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/oui_subtype (leafref)

    YANG Description: Reference to oui-subtype list key
    """
    return self.__oui_subtype
      
  def _set_oui_subtype(self, v, load=False):
    """
    Setter method for oui_subtype, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/oui_subtype (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oui_subtype is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oui_subtype() directly.

    YANG Description: Reference to oui-subtype list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="oui-subtype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oui_subtype must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui-subtype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__oui_subtype = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oui_subtype(self):
    self.__oui_subtype = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oui-subtype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/state (container)

    YANG Description: Operational state data 
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs_tlv_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs_tlv_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs_tlv_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

  type = __builtin__.property(_get_type)
  oui = __builtin__.property(_get_oui)
  oui_subtype = __builtin__.property(_get_oui_subtype)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('type', type), ('oui', oui), ('oui_subtype', oui_subtype), ('state', state), ])


class yc_custom_tlvs_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/lldp/neighbors/neighbor/custom-tlvs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of custom TLVs from a
neighbor
  """
  __slots__ = ('_path_helper', '_extmethods', '__tlv',)

  _yang_name = 'custom-tlvs'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tlv = YANGDynClass(base=YANGListType("type oui oui_subtype",yc_tlv_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs_tlv, yang_name="tlv", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type oui oui-subtype', extensions=None), is_container='list', yang_name="tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'ethernet', u'lldp', u'neighbors', u'neighbor', u'custom-tlvs']

  def _get_tlv(self):
    """
    Getter method for tlv, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv (list)

    YANG Description: List of custom LLDP TLVs from a neighbor
    """
    return self.__tlv
      
  def _set_tlv(self, v, load=False):
    """
    Setter method for tlv, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs/tlv (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tlv is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tlv() directly.

    YANG Description: List of custom LLDP TLVs from a neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("type oui oui_subtype",yc_tlv_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs_tlv, yang_name="tlv", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type oui oui-subtype', extensions=None), is_container='list', yang_name="tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tlv must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("type oui oui_subtype",yc_tlv_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs_tlv, yang_name="tlv", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type oui oui-subtype', extensions=None), is_container='list', yang_name="tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=False)""",
        })

    self.__tlv = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tlv(self):
    self.__tlv = YANGDynClass(base=YANGListType("type oui oui_subtype",yc_tlv_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs_tlv, yang_name="tlv", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type oui oui-subtype', extensions=None), is_container='list', yang_name="tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=False)

  tlv = __builtin__.property(_get_tlv)


  _pyangbind_elements = OrderedDict([('tlv', tlv), ])


class yc_neighbor_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/lldp/neighbors/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of LLDP neighbors. If the implementation only
supports one neighbor, this would always be a list with
one item. If the device and neighbor supported multiple
neighbors, which can be achieved via LLDP forwarding, then
this would be supported
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__state','__custom_tlvs',)

  _yang_name = 'neighbor'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__custom_tlvs = YANGDynClass(base=yc_custom_tlvs_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs, is_container='container', yang_name="custom-tlvs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'ethernet', u'lldp', u'neighbors', u'neighbor']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/id (leafref)

    YANG Description: System generated identifier for the neighbor on
the logical channel.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: System generated identifier for the neighbor on
the logical channel.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state (container)

    YANG Description: Operational state data 
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_custom_tlvs(self):
    """
    Getter method for custom_tlvs, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs (container)

    YANG Description: Enclosing container for list of custom TLVs from a
neighbor
    """
    return self.__custom_tlvs
      
  def _set_custom_tlvs(self, v, load=False):
    """
    Setter method for custom_tlvs, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor/custom_tlvs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_custom_tlvs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_custom_tlvs() directly.

    YANG Description: Enclosing container for list of custom TLVs from a
neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_custom_tlvs_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs, is_container='container', yang_name="custom-tlvs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """custom_tlvs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_custom_tlvs_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs, is_container='container', yang_name="custom-tlvs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__custom_tlvs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_custom_tlvs(self):
    self.__custom_tlvs = YANGDynClass(base=yc_custom_tlvs_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor_custom_tlvs, is_container='container', yang_name="custom-tlvs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

  id = __builtin__.property(_get_id)
  state = __builtin__.property(_get_state)
  custom_tlvs = __builtin__.property(_get_custom_tlvs)


  _pyangbind_elements = OrderedDict([('id', id), ('state', state), ('custom_tlvs', custom_tlvs), ])


class yc_neighbors_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/lldp/neighbors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of LLDP neighbors on
a logical channel
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor',)

  _yang_name = 'neighbors'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor = YANGDynClass(base=YANGListType("id",yc_neighbor_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'ethernet', u'lldp', u'neighbors']

  def _get_neighbor(self):
    """
    Getter method for neighbor, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor (list)

    YANG Description: List of LLDP neighbors. If the implementation only
supports one neighbor, this would always be a list with
one item. If the device and neighbor supported multiple
neighbors, which can be achieved via LLDP forwarding, then
this would be supported
    """
    return self.__neighbor
      
  def _set_neighbor(self, v, load=False):
    """
    Setter method for neighbor, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors/neighbor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor() directly.

    YANG Description: List of LLDP neighbors. If the implementation only
supports one neighbor, this would always be a list with
one item. If the device and neighbor supported multiple
neighbors, which can be achieved via LLDP forwarding, then
this would be supported
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_neighbor_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_neighbor_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=False)""",
        })

    self.__neighbor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor(self):
    self.__neighbor = YANGDynClass(base=YANGListType("id",yc_neighbor_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=False)

  neighbor = __builtin__.property(_get_neighbor)


  _pyangbind_elements = OrderedDict([('neighbor', neighbor), ])


class yc_lldp_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/lldp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: LLDP data for logical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__neighbors',)

  _yang_name = 'lldp'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbors = YANGDynClass(base=yc_neighbors_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'ethernet', u'lldp']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/config (container)

    YANG Description: LLDP configuration data for logical channels
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: LLDP configuration data for logical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state (container)

    YANG Description: LLDP operational state data for logical channels
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: LLDP operational state data for logical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_neighbors(self):
    """
    Getter method for neighbors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors (container)

    YANG Description: Enclosing container for list of LLDP neighbors on
a logical channel
    """
    return self.__neighbors
      
  def _set_neighbors(self, v, load=False):
    """
    Setter method for neighbors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp/neighbors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbors() directly.

    YANG Description: Enclosing container for list of LLDP neighbors on
a logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_neighbors_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_neighbors_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__neighbors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbors(self):
    self.__neighbors = YANGDynClass(base=yc_neighbors_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  neighbors = __builtin__.property(_get_neighbors, _set_neighbors)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('neighbors', neighbors), ])


class yc_ethernet_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top level container for data related to Ethernet framing
for the logical channel
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__lldp',)

  _yang_name = 'ethernet'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lldp = YANGDynClass(base=yc_lldp_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp, is_container='container', yang_name="lldp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'ethernet']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/config (container)

    YANG Description: Configuration data for Ethernet protocol framing on
logical channels
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for Ethernet protocol framing on
logical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state (container)

    YANG Description: Operational state data for Ethernet protocol framing
on logical channels
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for Ethernet protocol framing
on logical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_lldp(self):
    """
    Getter method for lldp, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp (container)

    YANG Description: LLDP data for logical channels
    """
    return self.__lldp
      
  def _set_lldp(self, v, load=False):
    """
    Setter method for lldp, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/lldp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lldp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lldp() directly.

    YANG Description: LLDP data for logical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_lldp_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp, is_container='container', yang_name="lldp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lldp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_lldp_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp, is_container='container', yang_name="lldp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__lldp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lldp(self):
    self.__lldp = YANGDynClass(base=yc_lldp_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_lldp, is_container='container', yang_name="lldp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  lldp = __builtin__.property(_get_lldp, _set_lldp)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('lldp', lldp), ])


class yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ingress/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the signal source for the
logical channel
  """
  __slots__ = ('_path_helper', '_extmethods', '__transceiver','__physical_channel',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__transceiver = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    self.__physical_channel = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'ingress', u'config']

  def _get_transceiver(self):
    """
    Getter method for transceiver, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/config/transceiver (leafref)

    YANG Description: Reference to the transceiver carrying the input signal
for the logical channel.  If specific physical channels
are mapped to the logical channel (as opposed to all
physical channels carried by the transceiver), they can be
specified in the list of physical channel references.
    """
    return self.__transceiver
      
  def _set_transceiver(self, v, load=False):
    """
    Setter method for transceiver, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/config/transceiver (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transceiver is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transceiver() directly.

    YANG Description: Reference to the transceiver carrying the input signal
for the logical channel.  If specific physical channels
are mapped to the logical channel (as opposed to all
physical channels carried by the transceiver), they can be
specified in the list of physical channel references.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transceiver must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)""",
        })

    self.__transceiver = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transceiver(self):
    self.__transceiver = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)


  def _get_physical_channel(self):
    """
    Getter method for physical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/config/physical_channel (leafref)

    YANG Description: This list should be populated with references
to the client physical channels that feed this logical
channel from the transceiver specified in the 'transceiver'
leaf, which must be specified.  If this leaf-list is empty,
all physical channels in the transceiver are assumed to be
mapped to the logical channel.
    """
    return self.__physical_channel
      
  def _set_physical_channel(self, v, load=False):
    """
    Setter method for physical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/config/physical_channel (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physical_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physical_channel() directly.

    YANG Description: This list should be populated with references
to the client physical channels that feed this logical
channel from the transceiver specified in the 'transceiver'
leaf, which must be specified.  If this leaf-list is empty,
all physical channels in the transceiver are assumed to be
mapped to the logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """physical_channel must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)""",
        })

    self.__physical_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_physical_channel(self):
    self.__physical_channel = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)

  transceiver = __builtin__.property(_get_transceiver, _set_transceiver)
  physical_channel = __builtin__.property(_get_physical_channel, _set_physical_channel)


  _pyangbind_elements = OrderedDict([('transceiver', transceiver), ('physical_channel', physical_channel), ])


class yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ingress/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the signal source for the
logical channel
  """
  __slots__ = ('_path_helper', '_extmethods', '__transceiver','__physical_channel',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__transceiver = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__physical_channel = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'ingress', u'state']

  def _get_transceiver(self):
    """
    Getter method for transceiver, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/state/transceiver (leafref)

    YANG Description: Reference to the transceiver carrying the input signal
for the logical channel.  If specific physical channels
are mapped to the logical channel (as opposed to all
physical channels carried by the transceiver), they can be
specified in the list of physical channel references.
    """
    return self.__transceiver
      
  def _set_transceiver(self, v, load=False):
    """
    Setter method for transceiver, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/state/transceiver (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transceiver is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transceiver() directly.

    YANG Description: Reference to the transceiver carrying the input signal
for the logical channel.  If specific physical channels
are mapped to the logical channel (as opposed to all
physical channels carried by the transceiver), they can be
specified in the list of physical channel references.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transceiver must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__transceiver = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transceiver(self):
    self.__transceiver = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_physical_channel(self):
    """
    Getter method for physical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/state/physical_channel (leafref)

    YANG Description: This list should be populated with references
to the client physical channels that feed this logical
channel from the transceiver specified in the 'transceiver'
leaf, which must be specified.  If this leaf-list is empty,
all physical channels in the transceiver are assumed to be
mapped to the logical channel.
    """
    return self.__physical_channel
      
  def _set_physical_channel(self, v, load=False):
    """
    Setter method for physical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/state/physical_channel (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physical_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physical_channel() directly.

    YANG Description: This list should be populated with references
to the client physical channels that feed this logical
channel from the transceiver specified in the 'transceiver'
leaf, which must be specified.  If this leaf-list is empty,
all physical channels in the transceiver are assumed to be
mapped to the logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """physical_channel must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__physical_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_physical_channel(self):
    self.__physical_channel = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)

  transceiver = __builtin__.property(_get_transceiver)
  physical_channel = __builtin__.property(_get_physical_channel)


  _pyangbind_elements = OrderedDict([('transceiver', transceiver), ('physical_channel', physical_channel), ])


class yc_ingress_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ingress. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for specifying references to the
source of signal for the logical channel, either a
transceiver or individual physical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state',)

  _yang_name = 'ingress'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'ingress']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/config (container)

    YANG Description: Configuration data for the signal source for the
logical channel
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the signal source for the
logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/state (container)

    YANG Description: Operational state data for the signal source for the
logical channel
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for the signal source for the
logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ])


class yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for tributary assignments
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__description','__assignment_type','__logical_channel','__optical_channel','__allocation','__tributary_slot_index','__mapping',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    self.__tributary_slot_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="tributary-slot-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=True)
    self.__assignment_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'LOGICAL_CHANNEL': {}, u'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=True)
    self.__logical_channel = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    self.__mapping = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:GFP_T': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:GFP_F': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GFP_F': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CBR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:BMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'BMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CBR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:GMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'AMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:AMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GFP_T': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)
    self.__allocation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=True)
    self.__optical_channel = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'logical-channel-assignments', u'assignment', u'config']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/index (uint32)

    YANG Description: Index of the current logical client channel to tributary
mapping
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of the current logical client channel to tributary
mapping
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/description (string)

    YANG Description: Name assigned to the logical client channel
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Name assigned to the logical client channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)


  def _get_assignment_type(self):
    """
    Getter method for assignment_type, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/assignment_type (enumeration)

    YANG Description: Each logical channel element may be assigned to subsequent
stages of logical elements to implement further grooming, or
can be assigned to a line-side optical channel for
transmission.  Each assignment also has an associated
bandwidth allocation.
    """
    return self.__assignment_type
      
  def _set_assignment_type(self, v, load=False):
    """
    Setter method for assignment_type, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/assignment_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_assignment_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_assignment_type() directly.

    YANG Description: Each logical channel element may be assigned to subsequent
stages of logical elements to implement further grooming, or
can be assigned to a line-side optical channel for
transmission.  Each assignment also has an associated
bandwidth allocation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'LOGICAL_CHANNEL': {}, u'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """assignment_type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-terminal-device:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'LOGICAL_CHANNEL': {}, u'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=True)""",
        })

    self.__assignment_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_assignment_type(self):
    self.__assignment_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'LOGICAL_CHANNEL': {}, u'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=True)


  def _get_logical_channel(self):
    """
    Getter method for logical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/logical_channel (leafref)

    YANG Description: Reference to another stage of logical channel elements.
    """
    return self.__logical_channel
      
  def _set_logical_channel(self, v, load=False):
    """
    Setter method for logical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/logical_channel (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_channel() directly.

    YANG Description: Reference to another stage of logical channel elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_channel must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)""",
        })

    self.__logical_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_channel(self):
    self.__logical_channel = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)


  def _get_optical_channel(self):
    """
    Getter method for optical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/optical_channel (leafref)

    YANG Description: Reference to the line-side optical channel that should
carry the current logical channel element.  Use this
reference to exit the logical element stage.
    """
    return self.__optical_channel
      
  def _set_optical_channel(self, v, load=False):
    """
    Setter method for optical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/optical_channel (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_channel() directly.

    YANG Description: Reference to the line-side optical channel that should
carry the current logical channel element.  Use this
reference to exit the logical element stage.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_channel must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)""",
        })

    self.__optical_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_channel(self):
    self.__optical_channel = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)


  def _get_allocation(self):
    """
    Getter method for allocation, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/allocation (decimal64)

    YANG Description: Allocation of the logical client channel to the tributary
or sub-channel, expressed in Gbps. Please note that if the
assignment is to an OTN logical channel, the allocation must
be an integer multiplication to tributary-slot-granularity
of the OTN logical channel.
    """
    return self.__allocation
      
  def _set_allocation(self, v, load=False):
    """
    Setter method for allocation, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/allocation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allocation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allocation() directly.

    YANG Description: Allocation of the logical client channel to the tributary
or sub-channel, expressed in Gbps. Please note that if the
assignment is to an OTN logical channel, the allocation must
be an integer multiplication to tributary-slot-granularity
of the OTN logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allocation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=True)""",
        })

    self.__allocation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allocation(self):
    self.__allocation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=True)


  def _get_tributary_slot_index(self):
    """
    Getter method for tributary_slot_index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/tributary_slot_index (int32)

    YANG Description: Indicates the first tributary slot index allocated to the
client signal or logical channel in the assignment. Valid
only when the assignment is to an OTN logical channel.
    """
    return self.__tributary_slot_index
      
  def _set_tributary_slot_index(self, v, load=False):
    """
    Setter method for tributary_slot_index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/tributary_slot_index (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tributary_slot_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tributary_slot_index() directly.

    YANG Description: Indicates the first tributary slot index allocated to the
client signal or logical channel in the assignment. Valid
only when the assignment is to an OTN logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="tributary-slot-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tributary_slot_index must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="tributary-slot-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=True)""",
        })

    self.__tributary_slot_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tributary_slot_index(self):
    self.__tributary_slot_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="tributary-slot-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=True)


  def _get_mapping(self):
    """
    Getter method for mapping, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/mapping (identityref)

    YANG Description: Logical channel mapping procedure. Valid only when the
assignment is to an OTN logical channel.
    """
    return self.__mapping
      
  def _set_mapping(self, v, load=False):
    """
    Setter method for mapping, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/mapping (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mapping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mapping() directly.

    YANG Description: Logical channel mapping procedure. Valid only when the
assignment is to an OTN logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:GFP_T': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:GFP_F': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GFP_F': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CBR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:BMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'BMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CBR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:GMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'AMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:AMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GFP_T': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mapping must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:GFP_T': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:GFP_F': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GFP_F': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CBR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:BMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'BMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CBR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:GMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'AMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:AMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GFP_T': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)""",
        })

    self.__mapping = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mapping(self):
    self.__mapping = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:GFP_T': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:GFP_F': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GFP_F': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CBR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:BMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'BMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CBR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:GMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'AMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:AMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GFP_T': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)

  index = __builtin__.property(_get_index, _set_index)
  description = __builtin__.property(_get_description, _set_description)
  assignment_type = __builtin__.property(_get_assignment_type, _set_assignment_type)
  logical_channel = __builtin__.property(_get_logical_channel, _set_logical_channel)
  optical_channel = __builtin__.property(_get_optical_channel, _set_optical_channel)
  allocation = __builtin__.property(_get_allocation, _set_allocation)
  tributary_slot_index = __builtin__.property(_get_tributary_slot_index, _set_tributary_slot_index)
  mapping = __builtin__.property(_get_mapping, _set_mapping)


  _pyangbind_elements = OrderedDict([('index', index), ('description', description), ('assignment_type', assignment_type), ('logical_channel', logical_channel), ('optical_channel', optical_channel), ('allocation', allocation), ('tributary_slot_index', tributary_slot_index), ('mapping', mapping), ])


class yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for tributary assignments
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__description','__assignment_type','__logical_channel','__optical_channel','__allocation','__tributary_slot_index','__mapping',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__tributary_slot_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="tributary-slot-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=False)
    self.__assignment_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'LOGICAL_CHANNEL': {}, u'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)
    self.__logical_channel = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__mapping = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:GFP_T': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:GFP_F': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GFP_F': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CBR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:BMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'BMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CBR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:GMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'AMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:AMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GFP_T': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    self.__allocation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__optical_channel = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'logical-channel-assignments', u'assignment', u'state']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/index (uint32)

    YANG Description: Index of the current logical client channel to tributary
mapping
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of the current logical client channel to tributary
mapping
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/description (string)

    YANG Description: Name assigned to the logical client channel
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Name assigned to the logical client channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_assignment_type(self):
    """
    Getter method for assignment_type, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/assignment_type (enumeration)

    YANG Description: Each logical channel element may be assigned to subsequent
stages of logical elements to implement further grooming, or
can be assigned to a line-side optical channel for
transmission.  Each assignment also has an associated
bandwidth allocation.
    """
    return self.__assignment_type
      
  def _set_assignment_type(self, v, load=False):
    """
    Setter method for assignment_type, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/assignment_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_assignment_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_assignment_type() directly.

    YANG Description: Each logical channel element may be assigned to subsequent
stages of logical elements to implement further grooming, or
can be assigned to a line-side optical channel for
transmission.  Each assignment also has an associated
bandwidth allocation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'LOGICAL_CHANNEL': {}, u'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """assignment_type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-terminal-device:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'LOGICAL_CHANNEL': {}, u'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)""",
        })

    self.__assignment_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_assignment_type(self):
    self.__assignment_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'LOGICAL_CHANNEL': {}, u'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)


  def _get_logical_channel(self):
    """
    Getter method for logical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/logical_channel (leafref)

    YANG Description: Reference to another stage of logical channel elements.
    """
    return self.__logical_channel
      
  def _set_logical_channel(self, v, load=False):
    """
    Setter method for logical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/logical_channel (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_channel() directly.

    YANG Description: Reference to another stage of logical channel elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_channel must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__logical_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_channel(self):
    self.__logical_channel = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_optical_channel(self):
    """
    Getter method for optical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/optical_channel (leafref)

    YANG Description: Reference to the line-side optical channel that should
carry the current logical channel element.  Use this
reference to exit the logical element stage.
    """
    return self.__optical_channel
      
  def _set_optical_channel(self, v, load=False):
    """
    Setter method for optical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/optical_channel (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_channel() directly.

    YANG Description: Reference to the line-side optical channel that should
carry the current logical channel element.  Use this
reference to exit the logical element stage.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_channel must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__optical_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_channel(self):
    self.__optical_channel = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_allocation(self):
    """
    Getter method for allocation, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/allocation (decimal64)

    YANG Description: Allocation of the logical client channel to the tributary
or sub-channel, expressed in Gbps. Please note that if the
assignment is to an OTN logical channel, the allocation must
be an integer multiplication to tributary-slot-granularity
of the OTN logical channel.
    """
    return self.__allocation
      
  def _set_allocation(self, v, load=False):
    """
    Setter method for allocation, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/allocation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allocation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allocation() directly.

    YANG Description: Allocation of the logical client channel to the tributary
or sub-channel, expressed in Gbps. Please note that if the
assignment is to an OTN logical channel, the allocation must
be an integer multiplication to tributary-slot-granularity
of the OTN logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allocation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__allocation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allocation(self):
    self.__allocation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_tributary_slot_index(self):
    """
    Getter method for tributary_slot_index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/tributary_slot_index (int32)

    YANG Description: Indicates the first tributary slot index allocated to the
client signal or logical channel in the assignment. Valid
only when the assignment is to an OTN logical channel.
    """
    return self.__tributary_slot_index
      
  def _set_tributary_slot_index(self, v, load=False):
    """
    Setter method for tributary_slot_index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/tributary_slot_index (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tributary_slot_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tributary_slot_index() directly.

    YANG Description: Indicates the first tributary slot index allocated to the
client signal or logical channel in the assignment. Valid
only when the assignment is to an OTN logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="tributary-slot-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tributary_slot_index must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="tributary-slot-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=False)""",
        })

    self.__tributary_slot_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tributary_slot_index(self):
    self.__tributary_slot_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="tributary-slot-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='int32', is_config=False)


  def _get_mapping(self):
    """
    Getter method for mapping, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/mapping (identityref)

    YANG Description: Logical channel mapping procedure. Valid only when the
assignment is to an OTN logical channel.
    """
    return self.__mapping
      
  def _set_mapping(self, v, load=False):
    """
    Setter method for mapping, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/mapping (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mapping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mapping() directly.

    YANG Description: Logical channel mapping procedure. Valid only when the
assignment is to an OTN logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:GFP_T': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:GFP_F': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GFP_F': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CBR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:BMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'BMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CBR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:GMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'AMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:AMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GFP_T': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mapping must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:GFP_T': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:GFP_F': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GFP_F': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CBR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:BMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'BMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CBR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:GMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'AMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:AMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GFP_T': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)""",
        })

    self.__mapping = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mapping(self):
    self.__mapping = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-opt-types:GFP_T': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:GFP_F': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GFP_F': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'CBR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:BMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'BMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:CBR': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:GMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'AMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'oc-opt-types:AMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GMP': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}, u'GFP_T': {u'@namespace': u'http://openconfig.net/yang/transport-types', u'@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)

  index = __builtin__.property(_get_index)
  description = __builtin__.property(_get_description)
  assignment_type = __builtin__.property(_get_assignment_type)
  logical_channel = __builtin__.property(_get_logical_channel)
  optical_channel = __builtin__.property(_get_optical_channel)
  allocation = __builtin__.property(_get_allocation)
  tributary_slot_index = __builtin__.property(_get_tributary_slot_index)
  mapping = __builtin__.property(_get_mapping)


  _pyangbind_elements = OrderedDict([('index', index), ('description', description), ('assignment_type', assignment_type), ('logical_channel', logical_channel), ('optical_channel', optical_channel), ('allocation', allocation), ('tributary_slot_index', tributary_slot_index), ('mapping', mapping), ])


class yc_assignment_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/logical-channel-assignments/assignment. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Logical channel elements may be assigned directly to
optical channels for line-side transmission, or can be
further groomed into additional stages of logical channel
elements.  The grooming can multiplex (i.e., split the
current element into multiple elements in the subsequent
stage) or de-multiplex (i.e., combine the current element
with other elements into the same element in the subsequent
stage) logical elements in each stage.

Note that to support the ability to groom the logical
elements, the list of logical channel elements should be
populated with an entry for the logical elements at
each stage, starting with the initial assignment from the
respective client physical port.

Each logical element assignment consists of a pointer to
an element in the next stage, or to an optical channel,
along with a bandwidth allocation for the corresponding
assignment (e.g., to split or combine signal).
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__config','__state',)

  _yang_name = 'assignment'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'logical-channel-assignments', u'assignment']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/index (leafref)

    YANG Description: Reference to the index for the current tributary
assignment
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Reference to the index for the current tributary
assignment
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config (container)

    YANG Description: Configuration data for tributary assignments
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for tributary assignments
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state (container)

    YANG Description: Operational state data for tributary assignments
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for tributary assignments
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  index = __builtin__.property(_get_index, _set_index)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('index', index), ('config', config), ('state', state), ])


class yc_logical_channel_assignments_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/logical-channel-assignments. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for tributary assignments
  """
  __slots__ = ('_path_helper', '_extmethods', '__assignment',)

  _yang_name = 'logical-channel-assignments'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__assignment = YANGDynClass(base=YANGListType("index",yc_assignment_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment, yang_name="assignment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'logical-channel-assignments']

  def _get_assignment(self):
    """
    Getter method for assignment, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment (list)

    YANG Description: Logical channel elements may be assigned directly to
optical channels for line-side transmission, or can be
further groomed into additional stages of logical channel
elements.  The grooming can multiplex (i.e., split the
current element into multiple elements in the subsequent
stage) or de-multiplex (i.e., combine the current element
with other elements into the same element in the subsequent
stage) logical elements in each stage.

Note that to support the ability to groom the logical
elements, the list of logical channel elements should be
populated with an entry for the logical elements at
each stage, starting with the initial assignment from the
respective client physical port.

Each logical element assignment consists of a pointer to
an element in the next stage, or to an optical channel,
along with a bandwidth allocation for the corresponding
assignment (e.g., to split or combine signal).
    """
    return self.__assignment
      
  def _set_assignment(self, v, load=False):
    """
    Setter method for assignment, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_assignment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_assignment() directly.

    YANG Description: Logical channel elements may be assigned directly to
optical channels for line-side transmission, or can be
further groomed into additional stages of logical channel
elements.  The grooming can multiplex (i.e., split the
current element into multiple elements in the subsequent
stage) or de-multiplex (i.e., combine the current element
with other elements into the same element in the subsequent
stage) logical elements in each stage.

Note that to support the ability to groom the logical
elements, the list of logical channel elements should be
populated with an entry for the logical elements at
each stage, starting with the initial assignment from the
respective client physical port.

Each logical element assignment consists of a pointer to
an element in the next stage, or to an optical channel,
along with a bandwidth allocation for the corresponding
assignment (e.g., to split or combine signal).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("index",yc_assignment_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment, yang_name="assignment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """assignment must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("index",yc_assignment_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment, yang_name="assignment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)""",
        })

    self.__assignment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_assignment(self):
    self.__assignment = YANGDynClass(base=YANGListType("index",yc_assignment_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment, yang_name="assignment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)

  assignment = __builtin__.property(_get_assignment, _set_assignment)


  _pyangbind_elements = OrderedDict([('assignment', assignment), ])


class yc_channel_openconfig_terminal_device__terminal_device_logical_channels_channel(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of logical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__config','__state','__otn','__ethernet','__ingress','__logical_channel_assignments',)

  _yang_name = 'channel'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    self.__ingress = YANGDynClass(base=yc_ingress_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress, is_container='container', yang_name="ingress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__otn = YANGDynClass(base=yc_otn_openconfig_terminal_device__terminal_device_logical_channels_channel_otn, is_container='container', yang_name="otn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__logical_channel_assignments = YANGDynClass(base=yc_logical_channel_assignments_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments, is_container='container', yang_name="logical-channel-assignments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__ethernet = YANGDynClass(base=yc_ethernet_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/index (leafref)

    YANG Description: Reference to the index of the logical channel
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Reference to the index of the logical channel
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/config (container)

    YANG Description: Configuration data for logical channels
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for logical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/state (container)

    YANG Description: Operational state data for logical channels
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for logical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_otn(self):
    """
    Getter method for otn, mapped from YANG variable /terminal_device/logical_channels/channel/otn (container)

    YANG Description: Top level container for OTU configuration when logical
channel framing is using an OTU protocol, e.g., OTU1, OTU3,
etc.
    """
    return self.__otn
      
  def _set_otn(self, v, load=False):
    """
    Setter method for otn, mapped from YANG variable /terminal_device/logical_channels/channel/otn (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_otn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_otn() directly.

    YANG Description: Top level container for OTU configuration when logical
channel framing is using an OTU protocol, e.g., OTU1, OTU3,
etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_otn_openconfig_terminal_device__terminal_device_logical_channels_channel_otn, is_container='container', yang_name="otn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """otn must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_otn_openconfig_terminal_device__terminal_device_logical_channels_channel_otn, is_container='container', yang_name="otn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__otn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_otn(self):
    self.__otn = YANGDynClass(base=yc_otn_openconfig_terminal_device__terminal_device_logical_channels_channel_otn, is_container='container', yang_name="otn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_ethernet(self):
    """
    Getter method for ethernet, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet (container)

    YANG Description: Top level container for data related to Ethernet framing
for the logical channel
    """
    return self.__ethernet
      
  def _set_ethernet(self, v, load=False):
    """
    Setter method for ethernet, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ethernet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ethernet() directly.

    YANG Description: Top level container for data related to Ethernet framing
for the logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ethernet_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ethernet must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ethernet_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__ethernet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ethernet(self):
    self.__ethernet = YANGDynClass(base=yc_ethernet_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_ingress(self):
    """
    Getter method for ingress, mapped from YANG variable /terminal_device/logical_channels/channel/ingress (container)

    YANG Description: Top-level container for specifying references to the
source of signal for the logical channel, either a
transceiver or individual physical channels
    """
    return self.__ingress
      
  def _set_ingress(self, v, load=False):
    """
    Setter method for ingress, mapped from YANG variable /terminal_device/logical_channels/channel/ingress (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ingress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ingress() directly.

    YANG Description: Top-level container for specifying references to the
source of signal for the logical channel, either a
transceiver or individual physical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ingress_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress, is_container='container', yang_name="ingress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ingress must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ingress_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress, is_container='container', yang_name="ingress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__ingress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ingress(self):
    self.__ingress = YANGDynClass(base=yc_ingress_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress, is_container='container', yang_name="ingress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_logical_channel_assignments(self):
    """
    Getter method for logical_channel_assignments, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments (container)

    YANG Description: Enclosing container for tributary assignments
    """
    return self.__logical_channel_assignments
      
  def _set_logical_channel_assignments(self, v, load=False):
    """
    Setter method for logical_channel_assignments, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_channel_assignments is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_channel_assignments() directly.

    YANG Description: Enclosing container for tributary assignments
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_logical_channel_assignments_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments, is_container='container', yang_name="logical-channel-assignments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_channel_assignments must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_logical_channel_assignments_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments, is_container='container', yang_name="logical-channel-assignments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__logical_channel_assignments = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_channel_assignments(self):
    self.__logical_channel_assignments = YANGDynClass(base=yc_logical_channel_assignments_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments, is_container='container', yang_name="logical-channel-assignments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  index = __builtin__.property(_get_index, _set_index)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  otn = __builtin__.property(_get_otn, _set_otn)
  ethernet = __builtin__.property(_get_ethernet, _set_ethernet)
  ingress = __builtin__.property(_get_ingress, _set_ingress)
  logical_channel_assignments = __builtin__.property(_get_logical_channel_assignments, _set_logical_channel_assignments)


  _pyangbind_elements = OrderedDict([('index', index), ('config', config), ('state', state), ('otn', otn), ('ethernet', ethernet), ('ingress', ingress), ('logical_channel_assignments', logical_channel_assignments), ])


class yc_logical_channels_openconfig_terminal_device__terminal_device_logical_channels(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container the list of logical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__channel',)

  _yang_name = 'logical-channels'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__channel = YANGDynClass(base=YANGListType("index",yc_channel_openconfig_terminal_device__terminal_device_logical_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels']

  def _get_channel(self):
    """
    Getter method for channel, mapped from YANG variable /terminal_device/logical_channels/channel (list)

    YANG Description: List of logical channels
    """
    return self.__channel
      
  def _set_channel(self, v, load=False):
    """
    Setter method for channel, mapped from YANG variable /terminal_device/logical_channels/channel (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel() directly.

    YANG Description: List of logical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("index",yc_channel_openconfig_terminal_device__terminal_device_logical_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("index",yc_channel_openconfig_terminal_device__terminal_device_logical_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)""",
        })

    self.__channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel(self):
    self.__channel = YANGDynClass(base=YANGListType("index",yc_channel_openconfig_terminal_device__terminal_device_logical_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)

  channel = __builtin__.property(_get_channel, _set_channel)


  _pyangbind_elements = OrderedDict([('channel', channel), ])


class yc_state_openconfig_terminal_device__terminal_device_operational_modes_mode_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/operational-modes/mode/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the platform-defined
operational mode
  """
  __slots__ = ('_path_helper', '_extmethods', '__mode_id','__description','__vendor_id',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vendor_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__mode_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'operational-modes', u'mode', u'state']

  def _get_mode_id(self):
    """
    Getter method for mode_id, mapped from YANG variable /terminal_device/operational_modes/mode/state/mode_id (uint16)

    YANG Description: Two-octet encoding of the vendor-defined operational
mode
    """
    return self.__mode_id
      
  def _set_mode_id(self, v, load=False):
    """
    Setter method for mode_id, mapped from YANG variable /terminal_device/operational_modes/mode/state/mode_id (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode_id() directly.

    YANG Description: Two-octet encoding of the vendor-defined operational
mode
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode_id must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)""",
        })

    self.__mode_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode_id(self):
    self.__mode_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /terminal_device/operational_modes/mode/state/description (string)

    YANG Description: Vendor-supplied textual description of the characteristics
of this operational mode to enable operators to select the
appropriate mode for the application.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /terminal_device/operational_modes/mode/state/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Vendor-supplied textual description of the characteristics
of this operational mode to enable operators to select the
appropriate mode for the application.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_vendor_id(self):
    """
    Getter method for vendor_id, mapped from YANG variable /terminal_device/operational_modes/mode/state/vendor_id (string)

    YANG Description: Identifier to represent the vendor / supplier of the
platform and the associated operational mode information
    """
    return self.__vendor_id
      
  def _set_vendor_id(self, v, load=False):
    """
    Setter method for vendor_id, mapped from YANG variable /terminal_device/operational_modes/mode/state/vendor_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendor_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendor_id() directly.

    YANG Description: Identifier to represent the vendor / supplier of the
platform and the associated operational mode information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vendor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vendor_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__vendor_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vendor_id(self):
    self.__vendor_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)

  mode_id = __builtin__.property(_get_mode_id)
  description = __builtin__.property(_get_description)
  vendor_id = __builtin__.property(_get_vendor_id)


  _pyangbind_elements = OrderedDict([('mode_id', mode_id), ('description', description), ('vendor_id', vendor_id), ])


class yc_mode_openconfig_terminal_device__terminal_device_operational_modes_mode(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/operational-modes/mode. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of operational modes supported by the platform.
The operational mode provides a platform-defined summary
of information such as symbol rate, modulation, pulse
shaping, etc.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mode_id','__state',)

  _yang_name = 'mode'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_operational_modes_mode_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__mode_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'operational-modes', u'mode']

  def _get_mode_id(self):
    """
    Getter method for mode_id, mapped from YANG variable /terminal_device/operational_modes/mode/mode_id (leafref)

    YANG Description: Reference to mode-id
    """
    return self.__mode_id
      
  def _set_mode_id(self, v, load=False):
    """
    Setter method for mode_id, mapped from YANG variable /terminal_device/operational_modes/mode/mode_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode_id() directly.

    YANG Description: Reference to mode-id
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode_id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__mode_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode_id(self):
    self.__mode_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/operational_modes/mode/state (container)

    YANG Description: Operational state data for the platform-defined
operational mode
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/operational_modes/mode/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for the platform-defined
operational mode
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_operational_modes_mode_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_operational_modes_mode_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_operational_modes_mode_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

  mode_id = __builtin__.property(_get_mode_id)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('mode_id', mode_id), ('state', state), ])


class yc_operational_modes_openconfig_terminal_device__terminal_device_operational_modes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/operational-modes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of operational modes
  """
  __slots__ = ('_path_helper', '_extmethods', '__mode',)

  _yang_name = 'operational-modes'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mode = YANGDynClass(base=YANGListType("mode_id",yc_mode_openconfig_terminal_device__terminal_device_operational_modes_mode, yang_name="mode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mode-id', extensions=None), is_container='list', yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'operational-modes']

  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /terminal_device/operational_modes/mode (list)

    YANG Description: List of operational modes supported by the platform.
The operational mode provides a platform-defined summary
of information such as symbol rate, modulation, pulse
shaping, etc.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /terminal_device/operational_modes/mode (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: List of operational modes supported by the platform.
The operational mode provides a platform-defined summary
of information such as symbol rate, modulation, pulse
shaping, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("mode_id",yc_mode_openconfig_terminal_device__terminal_device_operational_modes_mode, yang_name="mode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mode-id', extensions=None), is_container='list', yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("mode_id",yc_mode_openconfig_terminal_device__terminal_device_operational_modes_mode, yang_name="mode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mode-id', extensions=None), is_container='list', yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=YANGListType("mode_id",yc_mode_openconfig_terminal_device__terminal_device_operational_modes_mode, yang_name="mode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mode-id', extensions=None), is_container='list', yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)

  mode = __builtin__.property(_get_mode, _set_mode)


  _pyangbind_elements = OrderedDict([('mode', mode), ])


class yc_terminal_device_openconfig_terminal_device__terminal_device(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for the terminal device
  """
  __slots__ = ('_path_helper', '_extmethods', '__logical_channels','__operational_modes',)

  _yang_name = 'terminal-device'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__operational_modes = YANGDynClass(base=yc_operational_modes_openconfig_terminal_device__terminal_device_operational_modes, is_container='container', yang_name="operational-modes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__logical_channels = YANGDynClass(base=yc_logical_channels_openconfig_terminal_device__terminal_device_logical_channels, is_container='container', yang_name="logical-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device']

  def _get_logical_channels(self):
    """
    Getter method for logical_channels, mapped from YANG variable /terminal_device/logical_channels (container)

    YANG Description: Enclosing container the list of logical channels
    """
    return self.__logical_channels
      
  def _set_logical_channels(self, v, load=False):
    """
    Setter method for logical_channels, mapped from YANG variable /terminal_device/logical_channels (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_channels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_channels() directly.

    YANG Description: Enclosing container the list of logical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_logical_channels_openconfig_terminal_device__terminal_device_logical_channels, is_container='container', yang_name="logical-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_channels must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_logical_channels_openconfig_terminal_device__terminal_device_logical_channels, is_container='container', yang_name="logical-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__logical_channels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_channels(self):
    self.__logical_channels = YANGDynClass(base=yc_logical_channels_openconfig_terminal_device__terminal_device_logical_channels, is_container='container', yang_name="logical-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_operational_modes(self):
    """
    Getter method for operational_modes, mapped from YANG variable /terminal_device/operational_modes (container)

    YANG Description: Enclosing container for list of operational modes
    """
    return self.__operational_modes
      
  def _set_operational_modes(self, v, load=False):
    """
    Setter method for operational_modes, mapped from YANG variable /terminal_device/operational_modes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operational_modes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operational_modes() directly.

    YANG Description: Enclosing container for list of operational modes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_operational_modes_openconfig_terminal_device__terminal_device_operational_modes, is_container='container', yang_name="operational-modes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operational_modes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_operational_modes_openconfig_terminal_device__terminal_device_operational_modes, is_container='container', yang_name="operational-modes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__operational_modes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operational_modes(self):
    self.__operational_modes = YANGDynClass(base=yc_operational_modes_openconfig_terminal_device__terminal_device_operational_modes, is_container='container', yang_name="operational-modes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  logical_channels = __builtin__.property(_get_logical_channels, _set_logical_channels)
  operational_modes = __builtin__.property(_get_operational_modes, _set_operational_modes)


  _pyangbind_elements = OrderedDict([('logical_channels', logical_channels), ('operational_modes', operational_modes), ])


class openconfig_terminal_device(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /openconfig-terminal-device. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes a terminal optics device model for
managing the terminal systems (client and line side) in a
DWDM transport network.

Elements of the model:

physical port: corresponds to a physical, pluggable client
port on the terminal device. Examples includes 10G, 40G, 100G
(e.g., 10x10G, 4x25G or 1x100G) and 400G/1T in the future.
Physical client ports will have associated operational state or
PMs.

physical channel: a physical lane or channel in the
physical client port.  Each physical client port has 1 or more
channels. An example is 100GBASE-LR4 client physical port having
4x25G channels. Channels have their own optical PMs and can be
monitored independently within a client physical port (e.g.,
channel power).  Physical client channels are defined in the
model as part of a physical client port, and are modeled
primarily for reading their PMs.

logical channel: a logical grouping of logical grooming elements
that may be assigned to subsequent grooming stages for
multiplexing / de-multiplexing, or to an optical channel for
line side transmission.  The logical channels can represent, for
example, an ODU/OTU logical packing of the client
data onto the line side.  Tributaries are similarly logical
groupings of demand that can be represented in this structure and
assigned to an optical channel.  Note that different types of
logical channels may be present, each with their corresponding
PMs.

optical channel:  corresponds to an optical carrier and is
assigned a wavelength/frequency.  Optical channels have PMs
such as power, BER, and operational mode.

Directionality:

To maintain simplicity in the model, the configuration is
described from client-to-line direction.  The assumption is that
equivalent reverse configuration is implicit, resulting in
the same line-to-client configuration.

Physical layout:

The model does not assume a particular physical layout of client
and line ports on the terminal device (e.g., such as number of
ports per linecard, separate linecards for client and line ports,
etc.).
  """
  __slots__ = ('_path_helper', '_extmethods', '__terminal_device',)

  _yang_name = 'openconfig-terminal-device'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__terminal_device = YANGDynClass(base=yc_terminal_device_openconfig_terminal_device__terminal_device, is_container='container', yang_name="terminal-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_terminal_device(self):
    """
    Getter method for terminal_device, mapped from YANG variable /terminal_device (container)

    YANG Description: Top-level container for the terminal device
    """
    return self.__terminal_device
      
  def _set_terminal_device(self, v, load=False):
    """
    Setter method for terminal_device, mapped from YANG variable /terminal_device (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_terminal_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_terminal_device() directly.

    YANG Description: Top-level container for the terminal device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_terminal_device_openconfig_terminal_device__terminal_device, is_container='container', yang_name="terminal-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """terminal_device must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_terminal_device_openconfig_terminal_device__terminal_device, is_container='container', yang_name="terminal-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__terminal_device = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_terminal_device(self):
    self.__terminal_device = YANGDynClass(base=yc_terminal_device_openconfig_terminal_device__terminal_device, is_container='container', yang_name="terminal-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  terminal_device = __builtin__.property(_get_terminal_device, _set_terminal_device)


  _pyangbind_elements = OrderedDict([('terminal_device', terminal_device), ])


class openconfig_platform_linecard(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-linecard - based on the path /openconfig-platform-linecard. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines data related to LINECARD components in
the openconfig-platform model
  """
  _pyangbind_elements = {}

  

class openconfig_platform_transceiver(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-transceiver - based on the path /openconfig-platform-transceiver. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
for transceivers (i.e., pluggable optics).  The module should be
used in conjunction with the platform model where other
physical entity data are represented.

In the platform model, a component of type=TRANSCEIVER is
expected to be a subcomponent of a PORT component.  This
module defines a concrete schema for the associated data for
components with type=TRANSCEIVER.
  """
  _pyangbind_elements = {}

  

